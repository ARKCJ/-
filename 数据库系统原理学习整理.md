#                  数据库系统原理学习整理

#####                                                                （参考MOOC浙大教学）

#####   

​	**简介**：疫情在家，百般无赖，学校网课一知半解，特此自己重新系统学习了下数据库系统原理课程，该文章作为学习整理供以后参考，文章中大量示例为MOOC上浙江大学的数据系统原理课程，其中有很多示例作者已经整理完毕，并且争取做到通俗易懂，各位要学习的小伙伴可以参考以下作为学习笔记啦~

​    



​    学习该文章主要目的有三种，数据库模型与设计、编程，使用数据库、数据库管理系统实现。

1. **数据库模型与设计：**就是建立数据库模型，从现实中抽象出数据模型，在将其转换为适合的DBMS（数据库管理系统）的形式，也就是表和视图。
2. **编程，使用数据库：**查询、更新数据（SQL语言）。
3. **数据库管理系统实现：**数据库管理系统机制以及设计，包含数据库安全，防止恶意篡改，复制。











##### <a href="#第一章">数据库系统基本概念</a>

**<a href="#第二章">关系模型</a>**

**<a href="#第三章">SQL语言</a>**

**<a href="#第四章">ER图</a>**

**<a href="#第五章">函数依赖和关系模式分解</a>**

**<a href="#第六章">数据库管理实现技术</a>**







## <a name="第一章">第一章：数据库系统基本概念</a>

#### 1、数据库与数据库管理系统的定义：

​			**数据库（Database）：**简称DB，它是“按照数据结构来组织、存储和管理数据的仓库”。是一个长期存储在计算机内的、有组织的、可共享的、统一管理的大量数据的集合。其经过了一定的发展成为了现在成熟的类型，目前数据库主要分为两种类型，一种是目前已经非常成熟的类型，**关系型数据库**（Relational database），其主要以表的形式存储，表与表之间存在着大量关系，使其具有一定的关联性（我们最常使用的MySQL、SQL  Serever和Oracle都是关系型数据库），并且市面上常用的关系型数据库都共有同一套SQL（结构化查询语言，Structured Query Language）标准。另一种则是**非关系型数据库**，比如，网状型数据库、层次型数据库、面向对象型，这些数据库大多或因结构复杂被淘汰或是刚刚兴起。

​          数据库系统主要有三个层次的抽象：**物理层**（描述数据实际上是如何存储的，这个一般不是我们编程时要考虑的问题但也需要掌握）、**逻辑层**（描述数据库中存储什么数据以及这些数据存在什么样的关系。比方说，我们需要建立老师与学生的关系，老师和学生分别应该有什么属性，有什么样的关系）、**视图层**（考虑安全和管理问题，我们应该对所需要的数据进行展示对不必要的数据进行隐藏，我们需要建立一个虚拟的表也就是视图，视图是实际表的映射，并不会实际的存储数据，以上这些问题都会在后面展开细讲）。

<img src="https://i.loli.net/2020/05/10/xCU5VNs74SrqFhG.png" alt="IVXYD_C52_T3S926_A3_VYT.png" width = 500 />

​			**数据库管理系统(Database Management System)：**简称DBMS，数据库 + 一组用以访问、更新和管理这些数据的程序。其至少需要包含以下5种特性：**数据访问的高效和可扩展性**、**能够缩短应用开发时间**、**数据的独立性**（物理上独立\逻辑上独立，修改一层的结构不应该影响高层的结构定义，应用程序依赖逻辑结构并且独立于数据的结构与存储）、**数据完整性和安全性**、**并发访问和鲁棒性**（恢复）。



​           数据库为我们解决了一系列问题：

1. 数据冗余和不一致：多种文件格式、信息重复存储，增加访问效率，浪费物理空间。
2. 数据访问困难：每次都需要编写一个新的程序来完成一个新的任务。
3. 数据孤立：多文件多格式，检索、共享数据困难。
4. 完整性问题：编写程序会包含大量检查代码不宜维护（账户余额的判断必须大于等于0）。
5. 原子性问题：数据或者操作是非原子的，比如银行转账的出账和入账，要么同时一起成功，要么都别成功，不应该分开操作。
6. 并发访问异常：并发访问几乎是现代大多系统都具备的功能，要有一定的并发访问机制来保证数据一致和更新的问题（查看金额应该保证同一时间不同人访问时都会是一致的）。
7. 数据难以恢复：原数据一旦找到误操作或破坏，应该有一定的恢复机制。
8. 安全性问题：谁能访问，谁能修改，权限问题。



#### **2、实例和模式：**

​       实例和模式非常类似于编程语言种的变量（variables）和类型（type）。

```mysql
create table students(
    id int,
    name varchar(10)
);
```

如上，以插入id为目的的一系列数据集合就是**实例**（对应变量），int就是**模式**（对应类型，这里的模式细分应该是逻辑模式）。这个id会对应一系列有效插入到该表的数据集合，这些数据都应该满足int类型。在数据库设计中我们需要格外注重实例以及模式的设计，因为程序严重依赖于数据的逻辑结构。

<img src="https://i.loli.net/2020/05/10/sc9rbUiwYnVumOG.jpg" alt="qq_pic_merged_1589104744760.jpg" width = 500 />

#### **2、数据模型：**

​			数据模型是一个概念工具的集合，用于描述：数据结构、数据关系、数据语义、数据约束。

数据抽象的不同层次都需要不同的数据模型来描述：实体-关系模型（E-R图）、关系模型（表）、其他模型（面向对象模型、半结构化数据模型（XML）、层次模型、网状模型...）

#### **3、数据库的设计步骤：**

- 需求分析：需要什么样的数据、应用程序和业务。
-  概念设计：使用实体-关系模型（E-R图）或者其他高层次的数据模型来对其进行描述。
-  逻辑数据库设计： 将概念设计转换为某个DBMS所支持的关系模型。
-  结构优化：关系标准化，检查冗余和相关异常关系结构。可以说是对逻辑数据库结构设计的补充，是设计数            据库中第二重要，却是理论部分最难学的。
- 物理数据库设计：索引、集群和数据库调优（你肯定不希望你在上百万条数据中搜索时要用遍历的方法）。
- 创建并初始化数据库并进行安全设计
  - 加载初始数据并进行调试。
  - 识别不同的用户以及他们的职能。



#### **4、实体关系模型以及关系模型：**

**实体关系模型：**这里简要的说下什么是**实体关系模型**（Entity - Relationship）

​		E-R图主要包括两种对象：

- 实体（对象）：一个用矩形标明，中间含有实体名称的图像，在第五版E-R图中会以直线连接椭圆的方式来表示该实体所有的属性，也就是上面所说的实例（当然一个单独的属性并不能完整的代表一个实例）。
- 联系：通常以一个菱形来表示，连接一个甚至更多实体（通常是两个）来表示这些个实体之间的关系。

<img src="https://i.loli.net/2020/05/10/CdbI3K2HDjry8hP.png" alt="0OEC7K_0I8~21N7VX_C___8.png" width = 500 />

**关系模型**：由实体-关系模型转换为相应的数据库建表语言设计的模型称为关系模型。

<img src="https://i.loli.net/2020/05/10/E8i1lZ5dTAHpwsf.png" alt="FLY_FAP~V77VR7L9O5T65LL.png" width = 800 />

事实上，E-R图中的实体与关系转换为关系模型后都是以表的形式表示的，实体表如上包含着一系列必要的属性，关系表则为连接两个或多个实体表的表，我们可以通过搜索关系表来找到合适的实例（就是数据），这些在下面SQL语言学习那一章会介绍如何建表以及如何搜索。

#### **5、数据库语言（SQL结构化查询语言）：**

​			SQL语言 = DDL（数据定义语言Data Definition Language）+ DML（数据操纵语言Data Manipulation Language）+DCL（数据控制语言Data Control Language） 

- **DDL:**	
  - 指定一个数据库模式作为一组关系模式的定义。
  - 指定存储结构，访问方法一致性约束。
  - DDL语句经过编译后得到一组存储在一个特殊文件的表（比如.MDF文件或是.SQL文件），特殊文件包括数据字典（data dictionary），其中包含元数据（matadata）。
    - 数据字典包括：
      - 数据库模式
      - 数据存储结构
      - 统计方法和约束
      - 统计信息
      - 授权
  - 就比如MySQL的建表语言create table account(account_num char(10), balance integer);
- **DML:**也称为查询语言，在SQL中用户只需要表明自己想要什么数据而不用在乎如何得到这些数据（比如说二分法或者二叉树这类方法去得到数据），因此在SQL中DML是一种声明式语言，有些地方将DML与DQL（查询）刻意分开，但个人认为没必要。
  - 检索数据 select from
  - 插入/删除/更改 insert/delete/update
- **DCL:**数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。
  - 授权用户：grant
  - 回滚：rollback
  - 等等...



例如下面的两句SQL查询语句分别为根据用户的customer-id（192-83-7465）找到用户,以及找到客户（192-83-7465）所有的账户余额。

```mysql
select customer_name from customer where customer_id = '192-83-7465';
select account.balance from depositor , account where depositor.customer_id = '192-83-7465' and depositor.account_number = account.account_number;
```

看不懂没关系，认识一下就行。

下面是上面语句的查询示例：

<img src="https://i.loli.net/2020/05/10/f8ioFZSBnpePUYr.png" alt="P6_39K3_EULWEJW6K6NF__T.png" width = 700 />

​	SQL语言使用的方式有很多，可以在SQL的交互环境中使用比如MySQL的Workbench和命令行，SQL Server的查询分析器，或者是使用JDBC或ODBC，也可以是在宿主语言中使用嵌入式SQL（几乎不使用，针对不同的数据库还需要二次开发，重新编写程序）。

<img src="https://i.loli.net/2020/05/10/FHiRjXboNGLEf2y.jpg" alt="qq_pic_merged_1589109587677.jpg" width = 700 />



#### **6、数据库用户：**

数据库用户可分为：

- 无经验用户（使用事先编写好的程序来进行系统交互）
- 应用程序员（通过SQL调用与系统进行交互）
- 富有经验的用户（使用数据查询语言或数据分析软件等工具1表达他们的需求，比如，数据挖掘）
- 特殊用户（编写专门的，不适合传统数据处理框架的数据库应用）。
- 数据库管理员（DBA）一句话他最牛，想干嘛就干嘛，数据库有啥，他就能干啥。对数据库进行集中控制的用户。

#### **6、事务管理：**

​		**事物**：是SQL中最小的一个操作单位，事物应该具有：Atomicity（原子性）、Consistence（一致性）、Isolation（隔离性）、Durability(持久性)/ACID，这些会在后面的章节中细讲。

​		**事物管理组件**：确保系统在出现故障或者事物执行失败后，能够保证执行前与问题出现后数据的一致。

​		**并发控制管理器：**控制并发事务之间的交互。

#### **7、数据库体系结构：**

- 存储管理器

  - 在底层数据存储与引用程序以及查询之间，提供接口
  - 对数据库中的数据进行高效存储，检索和更新
  - 包括：
    - 事物管理
    - 授权和完整性管理
    - 文件管理（管理文件系统和数据文件，数据字典，索引文件之间的交互）
    - 缓存管理

- 查询处理器

  - 接受数据库语言的输入，经过解析、优化、执行，输出相应的结果给用户（编译原理，你懂的~）

  - 包括：

    - 解析和翻译
    - 优化
    - 执行

    

    数据库体系结构：

    <img src="https://i.loli.net/2020/05/10/xNKWQMOkEAbluZ4.jpg" alt="qq_pic_merged_1589110900512.jpg" width = 500 />


## **<a name="第二章">第二章：关系模型</a>**

#### 1、什么是关系模型？

​		由**实体-关系模型**转换为相应的数据库建表语言设计的模型称为关系模型。

​        **关系数据库**基于关系模型，是一个或多个关系组成的集合。这里的关系通俗所说就是表（行与列组成）。关系模型的优点在于对数据能够简单的表示，方便表示复杂的查询。

<img src="https://i.loli.net/2020/05/11/i1gSZaTDb7Uht4Q.png" alt="QSO7_5_786_Z_@XS2`V65SH.png" width = 500 />

​		上图的Instructor中的（ID,name,dept_name,salary）通俗的说就是**关系模型**（描述关系的结构），上面的各行数据的集合就是**实体集**，每一行数据就是一个**实体**（也叫关系实体），每一行数据在机器的层面上说就是一个**元组**。上图并没有表明所谓的**联系**，联系可以视为在另一张表中，它存储着两个（一般是两个）实体中的各某一个属性（这个属性对实体集来说，是至关重要，可分辨不同实体的属性，比如大家口中某个实体的key值），在这张表中的每一行数据就是一个实体对另一个实体的联系。**关系**涉及关系模型与关系实体两个概念。

​		一般的，数学会以R表示为关系模式，r（R）表示在R上的关系。

#### 2、码和键：

​		码和键是一个非常重要的概念，它为我们能够在一个关系中唯一的标识一个元组起着非常重要的作用。数学中通常以K来表示，这里的K⊆R。

​        提到码和键（都是一个意思，码就是键）这里就不得不提一下三个概念**超码，候选码，主码**。

- 超码：如果K能够在一个关系中能够唯一的标识一个元组，那么K就是超码。注意能够唯一标识，并不代表超码是唯一的，超码可以是一个集合（{{instructor_id、instructor_name}、{instructor_id}}），以上集合中的{instructor_id、instructor_name}和{instructor_id}都是超码。
- 候选码：如果K是最小超码，那么K就是候选码，上面例子中的{instructor_id}就是一个候选码，而{instructor_id、instructor_name}却不是，因为它可再分为{instructor_name}和{instructor_id}，而{instructor_id}也是一个超码。
- 主码：如果K是一个候选码，并由用户明确定义，那么K就是一个主码，主码通常这么表示（<u>K</u>）。

综上所述，主码⊆候选码⊆超码，**超码**就是能够唯一标识元组的属性集合的集合（类似二维数组），**候选码**就是超码中属性集合再分后不能够再称为超码的集合（还是二维数组，只不过是少了些），主码就是我们再候选码中挑一个合适的（一维数组）。

​	**外键：**对于一个关系中的某个属性（r（<u>A</u>,<font color = "blue">B</font>,C）），如果定义为外键(蓝色的B)，那么该属性就意味着对另一个关系（s（<font color = "blue"><u>B</u></font>，D））产生了依赖参照的关系（s叫做外码被参照关系）。比如对两张表choices（...,<font color = "blue">cid</font>,...）和courses（<font color = "blue"><u>cid</u></font>,...）,选课中的课程号cid起码必须要在课程中存在吧，谁也不能选一个根本就不存在的课，这就是外键的作用：参照某一个关系中的属性来限制这个关系，对该关系进行插入，删除，修改时应该也有相应的限制或是对应的操作。

#### 3、关系代数：

​		对数据库管理系统来说，查询语言是一系列的基础，而查询语言也可用数学符号来表示出来的（毕竟数学更是基础呗）。

**六个基本运算：**

- Select  选择  б
- Project 投影 П
- Union 并 ∪
- set difference  差（集合差）−
- Cartesian product 笛卡尔积 ×
- Rename 更名（重命名）ρx（E）

**附加运算：**基于六个基本运算推论得出的常用运算

- Set interection 交 ∩
- Natural join 自然连接 ⋈
- Division 除 ÷
- Assignment 赋值 ←

##### **选择运算：**

​				**σ**ρ（r）={t|t∈r and ρ（t）}，σ读作sigma，其中ρ为选择谓词，ρ是由¬（非）^（与）∨（或）连接起来的公式。逻辑连词的运算对象可以是包含比较运算符<,<=,>,>=,=和><的表达式 

​				<img src="https://i.loli.net/2020/05/11/unEjGr5BkfMLsqS.png" alt="Z3`N_AU5L7~AETFKJOS~9AJ.png" width = 500 />

**投影运算：**

​				 **П** A1，A2，...，Ak（r）， П读作pi，A1...Ak都为属性名，r为关系名，其结果保留这些K列的值，并**删除**重复的行。

​				<img src="https://i.loli.net/2020/05/11/nJN714C2sUtVyZr.png" alt="`_U0`8C9_FYJCJ_QN_@I_HJ.png" width = 500 />



**并运算：**

​			r∪s = {t|t∈r or t∈s}

​	**r∪s 条件：**

- 等目，同源，它们的属性数目必须相同
- 对任意i,r的第i个属性域和s的第i个属性域相同
- 比如 Пname（instructor）∪Пname（student）

<img src="https://i.loli.net/2020/05/11/7dSm9Aen3ytkKbf.png" alt="KKW_CMD_8W9__3W2IU`BVNC.png" width = 500 />



**差运算：**

​			r - s ={t|t∈ and t∉s}

​    **r - s 条件：**

- 等目，同源，它们的属性数目必须相同
- 对任意i，r的第i个属性域和s的第i个属性域相同
- 比如  Пname（instructor）- Пname（student）

<img src="https://i.loli.net/2020/05/11/1z7m92bHdrVZaxu.png" alt="D_63I0RN@QFXCUDZ71MQZDA.png " width = 600px />



**笛卡尔积：**

​				r × s = {{t q}|t∈ r and q ∈ s},这里需要注意的是如果r和s有同名属性，那么必须同命名这些属性。

笛卡尔积是一种暴力的将两个关系中互相结合的可能性全部罗列出来。假如r中有n1个元组，s中有n2个元组，

那么r × s后会有n1× n2个数目的元组（这里假设相同的元组不会被删除）。

<img src="C:\Users\蒋峻辰\AppData\Roaming\Typora\typora-user-images\image-20200511101644485.png" alt="image-20200511101644485" width = 500 />

**更名运算：**

​				允许我们使用其他名字指代关系

​				例如：ρx（E），ρ读作rho，返回表达式E的结果并将名字x赋给它。

![qq_pic_merged_1589163760992.jpg](https://i.loli.net/2020/05/11/McJLiHF27jC5U9l.jpg)

##### 复合运算：

​					可以使用多种运算符构建表达式，比如**б** A = C（r **×** s）、П A，C(**б** A = C（r **×** s）)

<img src="https://i.loli.net/2020/05/11/IRpZHUqT8tVcnw4.jpg" alt="qq_pic_merged_1589164186115.jpg" width = 500 />



#### 4、附加运算：

​						定义一些附加运算，它们虽然不能增加关系代数的表达能力，但是却可以简化一些常用的查询。注意，以上的定义运算在SQL查询语言中都有相对应的语言，但是下面的附加运算，有些SQL工具有，有些SQL工具没有。

**交运算：**

​			r∩s={t|t∈r and t∈s}

 **条件：**

 					- r和s同源
 					- r和s的属性是可兼容的
 					- r∩s = r - （r - s）

<img src="https://i.loli.net/2020/05/11/jdbMF1J6m4Vzp2E.png" alt="6G7__5RE@3Q9_IW_ZH_B_SU.png" width = 500 />

**自然连接：**r⋈s

​				对R = (A,<font color = "red">B</font>,C,<font color = "red">D</font>)  S = （E,<font color = "red">B</font>,<font color = "red">D</font>），R⋈S = （A,<font color = "red">B</font>,C,<font color = "red">D</font>,E）

​				r⋈s = **П**r.A,r.B,r.C,r.D,r.E(**б**r.B = s.B**^**r.D = s.D(r **×**s))

<img src="https://i.loli.net/2020/05/11/PMIYAgCQZBHj7nK.png" alt="0ZBU_RJBL_XSIF_CE`2_J_Q.png" width = 700 />

​         **theta连接**：r⋈θs = бθ（r × s）

**除：**

​	r÷s适用了包含了“对所有的”此类短语的查询

<img src="https://i.loli.net/2020/05/11/47MD6FsybrKgLRu.png" alt="_LJYJERCMNL3O8035LY__`J.png" width = 500/>

<img src="https://i.loli.net/2020/05/11/14IojYklLyeBdXC.jpg" alt="qq_pic_merged_1589167942046.jpg" width = 500 />

##### 赋值：

​		赋值运算目的是将复杂的查询表达变得简单

​		使用赋值运算，可以将查询表达为一个顺序程序，该程序包括：

- 一系列赋值
- 一个其值被作为查询结果显示的表达式

例如：可以把r÷s写作



​			temp1 ← **П**R-S（r）

​			temp2 ←   **П**R-S((temp1**×**s)-**П**R-S,S(r))

​			result = temp1 - temp2

#### 5、练习示例：

​		该实例在以后会反复用到。

​		假如有这么一个银行的数据库，里面存放着6个表这些表分别为：

​		branch（<u>branch-name</u>,branch-city,assets）

​		customer（<u>customer-name</u>,customer-street,customer-city）

​		account（<u>account-number</u>,branch-name,balance）

​		loan(<u>loan-number</u>,branch-name,amount)

​		depositor(<u>customer-name</u>,<u>account-number</u>)

​		borrower(<u>customer-name</u>,<u>loan-numbe</u>r)

**例1：**找出贷款额大于1200的分组

​		**б**amount  > 1200(loan)

**例2：**找出贷款大于1200的贷款号

​		**П**loan-number（**б**amount  > 1200(loan)）

**例3：**找出有贷款或者有账户或两种兼有的所有客户姓名

​		**П**customer-name(borrower)∪**П**customer-name(depositor)

**例4：**找出至少有一个贷款及一个账户的客户姓名

​		**П**customer-name(borrower)∩**П**customer-name(depositor)

**例5：**找出在Perryridge分支机构有贷款的顾客姓名

​		查询1：**П**customer-name(**б**branch-name = "Perryridge"(**б**borrower.loan-number = loan.loan-number(borrower × loan)))

​		查询2：**П**customer-name(**б**borrower.loan-number = loan.loan-number(borrower  **×** (**б**branch-name = "Perryridge"(loan))))

​		显然第二种查询方式效率会高很多，因为第一种无目的的笛卡尔积是非常耗时的。

**例6：**找出在Perryridge分支机构有贷款，但在其他分支机构没有账号的顾客姓名

​		**П**customer-name(**б**borrower.loan-number = loan.loan-number(borrower **×** (**б** branch-name = "Perryridge"(loan)))) - **П**customer-name(**б**borrower.loan-number = loan.loan-number **^** branch-name >< "Perryridge"(depositor **×** loan))

**例7：**找出银行中最大的账户余额

​		将account的关系重命名为d

​		第一步：找出非最大余额构成临时关系，这一步骤能够保证除了最大余额以外其他余额都能够记录：**П**account.balance(**б**account.balance < d.balance(account**×**ρd(account)))

​        第二步：找出最大余额：**П**balance(account) - **П**account.balance(**б**account.balance < d.balance(account**×**ρd(account)))

**例8：**找出至少拥有一个“市区”和“住宅区”分支机构的账户的客户姓名

​		**П**customer-name,branch-name(depositor**⋈**account) **÷** **ρ**temp(branch-name)({("Downtown"),("Uptown")})

#### 6、扩展代数关系运算：

##### 广义投影：

​				允许在投影列表中使用算术函数来对投影操作进行扩展，广义投影运算形式为：**П**F1,F2,...,F3(E)

这其中的E是任意关系代数表达式，F1,...,F2为涉及E模式中常量和属性的算数表达式。

例如：找出关系credit-info（customer-name,limit,credit-balance）,找出每个客户还能花费多少，可以表述为：

**П** <font size = 1>customer-name</font>,<font color = "red" size = 1>limit - credit-balance</font>(credit-info)

注意这里的limit - credit-balance就是一个函数，代表每个客户还能花费多少。

##### 聚集函数：

​				向聚集函数中输入一个值**集合**，然后返回单一值作为结果。

​                 一般的我们有：avg（平均值），min（最小值），max（最大值），sum（值得总和），count（值的				数量）。

聚集函数的关系代数表示为：<font size = 1>G1,G2,...,Gn</font> g<font size = 1>F1(A1),F2(A2),...,Fn(An)</font>   E是任意关系表达式，G1...Gn是用于分组的一系列属性，Fi是聚集函数，Ai是属性名。分组就是将元组集根据某个条件进行分组。

<img src="https://i.loli.net/2020/05/11/rTxU4tiS5JLC8zF.png" alt="O_A_K_SA_5_L`HG_UU5_I_V.png" width = 500 />

​    这里我们需要知道具体函数得到得结果是没有名称的，某些数据库系统使用聚集函数时会默认为聚集函数加属性作为名称avg（account）,或者我们可以根据(Fi（Ai）as newName)这样的形式为聚集函数的结果起一个新的名字<font size = 1>branch-name</font>g<font size = 1>sum(balance) as sum-balance</font>(account)。

##### 外连接：

​			外连接分为：左外连接、右外连接、全外连接

<img src="https://i.loli.net/2020/05/11/R6FMgIJL7vyeNl1.png" alt="6A3F1WNB_1_U7L~B__M7P94.png" width = 500/>

<img src="https://i.loli.net/2020/05/11/ipo1YPJTxgf2hbC.png" alt="TUZ4___4__D_6_BIU~J`6LU.png" width = 500 />



#### 7、空值：

​					如果要使用空值或者是出现空值，那么我们需要注意以下几点。

- 元组的某些属性值可以是空的（比如电话号可以是null）
- null表示未知值或值不存在
- 涉及空的任何算术表达式的结果为空（6 - null）= null
- 聚集函数会忽略某些空值
  - 可以返回空值
  - 我们遵循SQL对空值的处理语义
- 为了消除重复和分组，空值和其他值同等对待
  - 一种方法是两个空值被认为是相同的
  - 另一种方法是假设每个空值都是不同的
  - 以上两种方法都可行，但是我们更愿意遵循SQL对空值的处理语义



**下面就是SQL对空值的处理语义：**

T代表true，U代表Unknown也就是null，F代表false

<img src="https://i.loli.net/2020/05/11/DjdAf9rzEtK1n4C.png" alt="5``0PG_VND__0BA_X4_U3AX.png" width = 800 />

并且在SQL中，如果谓词P的值为unknown，那么“P is unknown”的值为真。

如果选择谓词的值为unknow，那么选择谓词的结果会被认为false。

#### 8、数据库的修改：

​		数据库的内容可以使用以下三种操作来进行修改：

​			1、删除

​			2、插入

​			3、更新

​		上面三种操作都可以用赋值的操作显示（A ← B）。

##### 删除：

​		删除请求的表达式与查询的表达式非常相似，不同的是，查找是为了将结果显示给用户，而删除是为了将结果从数据库中删除，并且这样的删除会将整个元组删除，并不能仅删除某些属性上的值。

​		删除可用关系代数表带为r **←**  r - E，r是关系，E是关系代数查询。

​       **例：**删除Perryrodge分支机构的所有账户

​				account **←** account - **б**<font size = 1>branch-name = "Perryrodge"</font>(account)

​		  	删除位于Needham的分支机构的所有账户

​				r1 **←** **б**<font size = 1>branch-city = "Needham"</font>(account**⋈**branch)

​				r2 **←** **П**<font size = 1>branch-name,account-number,balance</font>(r1)

​				r3 **←** **П**<font size = 1>customer-name,account-number</font>(r2**⋈**depositor)

​				account **←** account - r2

​				depositor **←** depositor - r3

##### 插入：

​		将数据插入到关系中有两种方式：

​		1、要么指明一个要插入的元组

​		2、要么写一个查询，其结果是要插入的元组集合

​		使用关系代数表示插入为 r **←** r ∪ E，r是关系，E是关系的代数表达式。

​		如果E是一个只包含元组的常量关系，就可以表达为向关系中插入单一元组。

​		**例：**

​			1、向accout和depositor关系中插入这样的元组，Smith在Perryridge分支机构的账户A-973上有1200块          

​			accout  **←** account ∪ {（“Perryidge”,A-973,1200）}

​			depositor  **←**  depositor ∪ {("Smith",A-973)}

​			2、假设对Perryridge分支机构的每一个贷款客户赠送一个新的200元的存款账户，并将其贷款号码作为此			账户的号码

​			思路：首先得找到在Perryridge分支机构的账户信息

​			r1  **←**  （ **б**<font size = 1>branch-name = "Perryridge"</font>(borrower**⋈**loan)）

​			向account中插入新的元组，存款为200，账号为贷款号码

​			account  **←** account ∪ **П**<font size = 1>branch-name,loan-number,200</font>(r1)

##### 更新：

​		更改某个元组或多个元组中的某个值。

​		可以用广义投影来表达这个操作  r  **←**  **П** <font size = 1>F1,F2,...,Fi,...,Fn</font>(r)，如果我们希望第i个属性不被修改，那么Fi表示的是原r		的第i个属性，当第i个属性将被修改时，Fi表示的是一个只涉及常量和r的属性的表达式，表达式给出此属性的		新值。

​		**例：**

​			假设要付给所有账户5%的利息

​				account  **←**  **П**<font size = 1>AN,BN,BAL*1.05</font>(acccount)

​			假设余额超过10000以上的账户得到6%的利息，其他账户得到5%的利息

​				account **←** **П**<font size =1>AN,BN,BAL*1.06</font>(**б**<font size = 1>BAL > 10000</font>(account))∪**П**<font size =1>AN,BN,BAL*1.05</font>(**б**<font size = 1>BAL <= 10000</font>(account))



## **<a name="第三章">第三章：SQL语言</a>**

​		SQL语言是由以下三个部分构成：

- DDL (Data-definition Language) 数据定义语言

  - ```sql
    create table , alter table , drop table // 对表进行的操作
    create index , drop index // 对索引进行的操作
    create view , drop view // 对视图进行的操作
    create trigger , drop trigger //对触发器进行的操作
    ```

- DML (Data-manipulation Language) 数据操纵语言

  - ```sql
    select ... from // 查询
    insert , delete , update // 更新数据
    ```

- DCL（Data-control Language）数据控制语言

  - ```sql
    grant , revoke // 权限相关
    ```





### 1、数据定义：

在数据库中，关系集合必须由DDL指定给系统。

**例如：**	

```sql
CREATE TABLE instructor(
			ID char(5),
			name varchar(20) not nunll,
			dept_name varchar(20),
			salary numeric(8,2),
			primary key(ID) // 主码
);
```

如上例，SQL的DDL不仅能够定义一组关系，同时也能够定义每个关系的信息，包括：

- 每个关系模式，instructor(ID , NAME , DEPT_NAME , SALARY)
- 每个属性的取值类型 ID char（5）...
- 完整性约束 以后会说，也是非常重要
- 每个关系维护的索引集合 ， 提高检索，存储效率
-  每个关系的安全性和权限信息，授权，撤销权力
- 每个关系在磁盘上的物理存储结构

**基本类型：**

- **char(n)** : 固定长度字符串， 用户指定长度。
- **varchar(n)** : 可变长度字符串，用户指定最大长度n。
- **int** : 整数类型（和机器相关的整数类型的子集），等价于全程integer ，虽然是和具体及其相关，但是一般为四个字节，范围是 -2147483648—2147483647或0—4294967295。注意如果这样year  INT（4）定义，代表year字段中的数据一般只显示4位数字的宽度，注意该定义不会影响到插入数据的大小(只要不超过指定的类型大小仍然可以插入，比如，插入10000仍然可以正常插入，并且使用select语句时是可以正常显示10000的)，只会影响到插入比4位小的数字的显示（比如插入4，select语句显示时会多三个空格补充）。
  - int类型在一般的数据库管理系统中都会扩充为其他类型比如TINYINT（1字节）、SMALLINT(2字节)、MEDIUMENT（3字节）、BIGINT（8字节），最好是根据数据系统的需要来定义合适范围的类型，这样会提高检索和存储的效率。
- **smallint** : 小整数类型（和及其相关的整数类型的子集）
- **numeric(p,d)** : 定点数，精度由用户指定。这个数有p位数字，其中d位数字在小数点右边，存储空间不固定，占用p+2个字节
- **real , double precision** : 浮点数与双精度浮点数，精度与机器相关，占8个字节
- **float(n)** :精度至少为n位的浮点数，占4个字节，
- **null** : 每种类型都可以包含一个特殊值，就是null值。可以申明属性值不为空值（not null），禁止加入空值
- **data** : 日期，含年，月，日，如'2015-3-20'，格式为YYYY-MM-DD
- **time** : 时间，含小时，分钟，秒，如'08：15：30'或'08：15：30.75'范围为 -838：59：59—838：59：59  格式为 HH：MM：SS
- **timestamp** :日期+时间，如'2015-3-20 08：15：30.75'格式为YYYY-MM-DD HH：MM：SS
- SQL中的各种函数，这些函数用于处理各种类型的数据以及其类型的转换，但各个数据库系统中函数的标准化程度不高。（substring(s, start, length) , getdate() , datalength( 'abc' )）

**基本模式定义：**

**我们用create table命令定义sql关系:**

```sql
create table r( // r是关系名        
    A1 D1,		// Ai是关系r中的一个属性名，Di是属性Ai的域
    A2 D2,
    A3 D3,
    .....,
    An Dn
    <完整性约束1>,
    ...
    <完整性约束k>
);
```

完整性约束是一个重要而且复杂的问题，目前我们只需要知道少数的几个完整性约束作为下面学习的基础。

- not null，在一个属性后面跟not null代表该属性不允许为空值，如：deptId integer not null
- primary key(A1,...A2)，声明表示属性A1，...，An构成关系的主码。主码属性必须非空并且唯一，如果是单独一个元素作为主码，也可单独跟在属性后面，如：deptId integer primary key
- foreign key(A1,...,Am) feferences，声明表示关系中任意元组属性上（A1,...,A2）的取值必须对应于关系s中某元组的主码属性上的取值。
- check(P),P是谓词条件，限定某一属性的取值范围
- constrain 名称，为某个限制条件取一个名称，方便管理，如：constrain example1 foreign key(deptId) reference tb_dept1(id)

例如：声明ID为instructor的主码，并确保salary的值非负

```SQL
create table instructor(
    ID char(5) not null,
    name varchar(20) not null,
    dept_name varchar(20),
    salary numeric(8,2),
    primary key (ID),
    constraint checkExample check(salary >= 0)
);
```

**我们也可以对表进行相应的修改：**

- 使用drop table命令，从数据库中删除关于被去掉关系的所有信息，简而言之就是删除一个表。
  - drop table r;
  - 如：drop table instructor2；
- 我们用alter table命令，为已有关系增加属性
  - alter table r add A D；A是一个属性名，D是属性A的域，添加完成后所有已经存在的元组在新属性上的取值将变为null
  - 如：alter table instructor add birthday date;
- 我们也可以用alter table命令，从关系中去掉属性
  - alter table r drop a
  - 有一些数据库并不支持这类操作，因为数据库都有映射视图功能，没必要去删除某个属性，盲目删除可能会出现意想不到的错误。
- 我们也可以用alter table命令，修改关系中的属性
  - ​	如，alter table instructor modify name varchar(30);

**以下是MySQL中对表常用的操作语句：**

```mysql
alter table <旧表名> rename <新表名>; // 修改表明
alter table <表名> modify <字段名> <新数据类型>; // 修改字段的数据类型
alter table <表名> change <旧字段名> <新字段名> <新数据类型>; // 修改字段名
alter table <表名> add <新字段名> <数据类型>;// 添加字段
alter table <表名> add <新字段名> <数据类型> first;// 在表的第一列添加字段
alter table <表名> add <新字段名> <数据类型> after <字段名>;// 在表的指定列之后添加一个字段
alter table <表名> drop <字段名>; // 删除字段
alter table <表名> modify <字段1> <数据类型> first|after <字段2>;// 修改字段的排列位置
alter table <表名> drop foreign key <外键约束名>; // 删除表的外键约束
```

#### 视图：

​		这一小节涉及到下面数据操纵的知识，可以先了解下面的知识再回顾这一小节。

**为什么要使用视图：**视图一般会与权限或者方便查阅相挂钩，因此，在某些情况下让用户看到整个逻辑模型是不合        									适的。假如我们希望某个职员需要知道教师的标识，姓名和所在的系名，但是并没有权限看									到教师的工资，那么应该用 `select ID,name,dept_name from instructor;`来进行映射									描述，但这样的操纵仍然是对原来的表进行的操纵，而视图就为我们提供了向用户隐藏特定									的数据的机制，让我们能够使用视图来方便管理。

**视图定义：**SQL允许通过查询来定义“虚关系”，它在概念上包含查询的结果，但并不预先计算并存储（物理存储还      					是原有表的位置）。像这种作为虚关系对用户可见的关系称为视图（view）。

**注意：**	当我们定义一个视图时，数据库系统存储的是视图定义本身，并不会存储定义该视图的查询表达式的			    执行结果。

​				一旦定义了一个视图，就可以用视图名指代该视图生成的虚关系。由于数据库只存储视图定义本身，那				么当视图关系出现在查询中时，它就会被已存储的查询表达式代替。（在视图中查询相关属性等同于在   				已经定义好的查询子句中进行二次查询）

**视图语句：**

- 视图的命令格式为：`create view v as < query expression >` , `< query expression >`可以是任何合法的查询表达式，v表示视图名。

- 对应的删除视图为：`drop view v`

- 对于视图的更新语句如同对表的更新语句，但是会有一定的限制，如果满足以下几种条件，那么就称该SQL视图是可更新的（插入，更新，删除）

  - from子句只有一个数据库关系
  - select子句中只包含关系的属性名，不包含任何表达式，聚集或者distinct声明
  - 任何没有出现在select子句中的属性可以取空值；即这些属性上没有not null约束，也不构成主码的一部分
  - 查询中不含有group by或having子句
  - 及时满足上面几种条件，该视图也不一定是可更新的（比如我们对instructor建立了一个针对历史系老师的视图，而我们想向其中插入生物系的老师元组，这样肯定是不符合逻辑的），因此在定义视图时，我们应该在视图定义的末尾加入 with check option 子句来定义视图，作为更新检查。

- 例，重新考虑需要访问instructor关系中除salary之外的所有数据，该视图的定义如下：

  ```mysql
  create view faculty as 
  select ID,name,dept_name
  from instructor;
  ```

- 例，创建一个视图，列出Physics系所在2009年秋季学期开始的所有课程，以及每个课程在哪栋建筑的哪个房间授课的信息：

  ```mysql
  create view physics_fall_2009 as
  select course.course_id,sec_id,building,room_number
  from course,section
  where course.course_id = section.course_id
  	      and course.dept_name = 'Physics'
  	      and section.semester = 'Fall'
  	      and section.year = '2009';
  ```

- 例，我们也可以同时对视图和视图的属性进行命名，列出每个系中所有教师工资的总和：

  ```mysql
  create view department_total_salary(dept_name,total_salary) as 
  select dept_name,sum(salary)
  from instructor
  group by dept_name;
  ```

- 例，在已经定义好的视图中(physics_fall_2009)，列出2009年秋季学期在Watson大楼开设的所有Physics课程的标识和教师号：

  ```mysql
  select course_id , room_number from physics_fall_2009
  where building = 'Watson';
  ```

- 例，删除视图physics_fall_2009：

  ```mysql
  drop view physics_fall_2009;
  ```



**物化视图：**特定数据库允许存储视图关系，并且保证，如果定义视图的实际关系改变，视图也会跟着修改，比如，    					若视图department_total_salary是物化的，那么它的结果会存放在数据库中（这与上面所说不会存放					实际数据不同）。

- 物化视图维护，既然是有实际存储的数据，那么这些数据应该被维护。物化视图维护通常简称试图维护：保持物化视图一直在最新状态的过程。共有三种维护方式。
  - 当构成视图定义的任何关系被更新时，进行视图维护
  - 当视图被访问时，才进行视图维护
  - 周期性地进行视图维护（这种情况下，访问的数据可能是过时的）

#### 索引：

**为什么要使用索引：**这需要理解数据库的数据在硬盘中的物理存储方式（会在以后详细说明），最坏的情况下，我								们搜索某些属性可能意味着我们需要在物理存储单元中（硬盘的一簇，其中包含着若干个扇								区）挨着顺序搜索，这会浪费大量的时间。如若我们针对我们常用的搜索属性（比如说键值）								建立相应的索引（类似于书的目录，方便我们更快定位到想要的数据，一种数据结构），这样								数据库就能高效的找到关系中那些在索引属性取给定值的元组，而不是扫描关系中的所有元								组。

**索引定义：**索引是一个单独的，存储在磁盘上的数据库结构，包含着对数据表里所有记录的引用指针。索引用于快					速找出在某个或多个列中有一特定值的行。如在MySQL中，所有的列类型都可以被索引，并且索引的					存储类型分为BTREE和HASH两种。简单说这一种用空间换速度的方案，并且也会降低数据的更新效					率。

**索引的分类以及相应语句（以MySQL为例）：**

- **普通索引：**普通索引是MySQL中基本的索引类型，允许在定义索引的列中插入重复值和空值。

  - 创建表时创建索引：

    ```mysql
    create  table table_name [col_name data_type]
    [UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] [index_name] (col_name[length])[ASC|DESC]
    ```

    UNIQUE、FULLTEXT、SPATIAL都为可选参数，表示唯一、全文和空间索引；

    INDEX和KEY同义词，作用相同，用来指定创建索引；

    col_name为需要创建索引的字段列；

    index_name指定索引的名称；

    length为可选参数，表示索引的长度，只有字符串类型的字段才可指明长度；

    ASC和DESC指定升序或者降序的索引值存储；

    ```mysql
    create table exampleTable(
    	bookid int,
        bookname varchar(255),
        authors varchar(255),
        INDEX index_1(bookid)
    );
    ```

  - 使用alter table语句创建索引：

    ```mysql
    alter table table_name add [UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY]
    [index_name] (col_name[length],...) [ASC|DESC]
    ```

    ```mysql
    alter table exampleTable add index index_2(bookname(30));
    ```

  - 使用create index语句创建索引：

    ```mysql
    create [UNIQUE|FULLTEXT|SPATIAL] index index_name
    ON table_name(col_name[length],...) [ASC|DESC]
    ```

    ```mysql
    create index index_3 on book(authors);
    ```

  - 使用alter table删除索引:

    ```mysql
    alter table table_name drop index index_1;
    ```

  - 使用drop index语句删除索引：

    ```mysql
    drop index index_2 on table_name;
    ```

    

- **唯一索引：**索引列的值必须唯一，但允许有空值。如果是组合索引，那么该组合必须唯一。主键索引是一种特                         殊的唯一索引，不允许有空值。

- **单列索引：**单列索引即一个索引只包含单个列，一个表可以有多个单列索引。

- **组合索引：**组合索引指在表的多个字段组合上创建的索引，只有在查询条件中适用了这些字段的左边字段时，索引才会被使用。使用组合索引时遵循最左前缀集合。

- **全文索引：**全文索引类型为FULLTEXT，在定义索引的列上支持值得全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在CHAR,VARCHAR或者TEXT类型的列上创建。MySQL中只有MyISAM存储引擎支持全文索引。

#### 事物：

​		在SQL语句中，最小的基本单位就是一个事务。默认下每个SQK语句自成为一个事物，并且一旦执行就完成提交。

​		SQL规定当一个SQL语句被执行就隐式的开始了一个事务，下面SQL语句之一会结束一个事物：

- Commit work:提交当前事务，也就是将该事务所做的更新在数据库中持久保存。当一个事务被提交后，一个新事物自动开始
- Rollback work：回滚当前事务，即撤销该事务中所有SQL语句对数据库的更新。这样数据库就会恢复到执行该事务第一条语句之前的状态。

**例如：**

```mysql
start transaction;
update account set balance = balance - 10 where account_number = 'A-101';
update account set balance = balance + 10 where account_number = 'A-201';
commit work;
```

以上的示例中，如果其中一个更新成功，另一个失败，那么则会都更新失败。事物会使得一个事务中包含多条SQL语句要么都执行成功，要么都执行失败，若执行失败后会完成回滚动作（数据库回到执行之前的状态）。

像上面例子中，如果想要将多条SQL语句包含在一起作为一个事务，需要关闭SQL语句的自动提交（在MySQL中是 `SET AUTOCOMMIT=0;`）

如下面的例子：

```mysql
set autocommit=0;
start transaction;
insert into testTable values(1);
insert into testTable values(2);
select * from testTable;
```

如果执行上面全部语句成功后此时，查看表中的数据后会包含我们已经插入的数据1和2，可是当我们关闭MySQL客户端再次打开客户端时，再次查看数据会发现插入的1和2已经不存在了。这就代表在事物结束之前（commit work）该事物的全部执行的SQL语句都不会实际执行成功。在该代码结尾加入（`commit work;`）后就会**完成该事务**。当然在结尾处加入（`rollback work;`）也会结束该任务并且完成到该事物**开启前**的状态。

如下面的例子：

```mysql
start transaction;
insert into testTable values(1);
savepoint point1;
insert into testTable values(2);
rollback to point1;
```

也会完成该事物但是会回滚到point1的位置，也就是说当我们关闭MySQL客户端再次打开后查看表中的数据就会只有1保存在了数据库中。

**事物的四个性质：**

- 原子性（atomic）：事物是不可分割的最小操作单位，要么同时成功，要么同时失败。
- 一致性（consistency）：事务操作前后，数据总量不变。 
- 隔离性（isolation）：多个事务之间。相互独立。
- 持久性（durability）：当事务提交或回滚后，数据库会持久化的保存数据。



#### 完整性约束：

完整性约束对于数据库中关系的设计是相对重要的一环，一个好的完整性约束设计保证我们设计的关系不会被不合逻辑的操作所破坏（比如instructor的salary应该大于等于0，name不应该为null值，course关系中的每个系名必须在department关系中有一个对应的系名）。**完整性约束保证授权用户对数据库所作的修改不会破坏数据的一致性。**

**完整性约束包括但不限于：**

- 域完整性
- 实体完整性（主键的约束）
- 参照完整性（外键的约束）
- 用户定义的完整性约束

**单个关系上的约束：**not null（关于该属性的列不为空值），unique（关于该属性的列取值应该唯一），check（<谓词>）（关于该属性的列的值应该遵循谓词条件）

如：

```mysql
create table instructor(
	ID char(5) primary key,
    name varchar(20) not null,
    salary numeric(8,2) not null,
    constraint check_salary check(salary >= 0)
);
```

**域约束：**域约束时完整性约束的最基本的形式，用于检查插入到数据库中的数据的合法性(注意以下SQL语句在某些数据库中未必支持)，简单说就是防止相同类型的数据属性值，不合逻辑的相互赋值。

如：

```sqlite
create domain Dollars as numeric(12,2) not null;
create domain Pounds as numeric(12,2) not null;
create table instructor(
	ID char(5) primary key,
    name varchar(20),
    dept_name varchar(20),
    salary Dollars,
    comm Pounds
);
```

**参照完整性：**参考前几节介绍的外键的定义，完整的定义如下：

令关系r1和r2的属性集分别为R1和R2，主码分别为K1和K2。如果要求对r2中任意元组t2，都存在r1中的元组使得t1[K1] = t2[a]，我们称R2的子集a为参照关系r1中K1的外码（foreign key）

**外码对于数据库修改的影响：**假设r2关系参照r1关系

- 插入：如果像r2中插入元组，就必须保证它的外键参照关系r1包含该元组的外键内容。
- 删除：如果从r1中删除元组，则必须保证r2中没有参照r1中即将被删除的元组，否则该删除命令会被撤销并且报错。又或者会产生级联删除（定义外键后加上`on delete cascade`，参照该元组的所有元组都一起被删除）。
- 更新：若想照成级联操作则在后面加上`on update cascade`
  - 如果更新的是r2中外键上的值，那么如同插入操作
  - 如果更新的是r1中被参照的元组值，那么如同删除操作

如：

```mysql
create table department(
	dept_name varchar(20),
    building varchar(15),
    budget numeric(12,2) check(budget > 0),
    primary key(dept_name)
);
create table course(
	course_id varchar(8),
    title varchar(50),
    dept_name varchar(20),
    credits numeric (2,0) check(credits > 0),
    primary key (course_id),
    constraint dept_name_department foreign key(dept_name) references department
);
```

#### 断言（assertion）：

​		断言就是表达要求数据库永远满足的条件的谓词（同check，但比check复杂）,以下是断言在SQL语句中的基本形式：`create assertion <assertion-name> check <P>`,p是谓词。

​		创建断言后，系统将会对每一个可能破坏该断言的数据库更新进行检测（断言的检测可能会相当耗费系统资源，因此断言使用应该谨慎）。并且断言并不是每一个数据库管理系统都支持的，具体要看是什么数据库管理系统。

例，每位教师不能再同一个学期的同一个时间段在两个不同的教室授课：

```plsql
create assertion ins_teachers_constraint check not exists
	(select ID,name,section_id,semester,year,time_slot_id,
     count(distinct building,room_number)
    from instructor natural join teaches natural join section group by
    (ID,name,section_id,semester,year,time_slot_id) having count(building,room_number) > 1);
```

#### 触发器（trigger）：

触发器是嵌入到MySQL的一段程序，触发器需要由事件来触发某个操作，它是由数据库更新操作引起的被系统自动执行的语句。



设计一个触发器必须明确：触发器被执行的条件和触发器执行时所做的具体操作。



在MySQL中视图和临时的表是无法使用触发器的，不同数据库对触发器语句的格式也不同，这里就讲解MySQL的触发器语句格式：

- 创建只有一个执行语句的触发器MySQL格式：

  ```mysql
  create trigger trigger_name trigger_time trigger_event 
  	on tb1_name for each row trigger_stmt;
  ```

  trigger_name:触发器名称

  trigger_time:触发触发器的时机，可以指定为before和after

  trigger_event:触发触发器的事件，包括insert、update和delete

  tb1_name:触发的表名，即在哪张表上触发触发器

  trigger_stmt:触发器执行的语句

  触发中需要知道的两个重要属性：**NEW**和**OLD**，NEW表示触发触发器执行的更新语句执行后的元组（对插入和修改有效），OLD表示该语句执行前的元组（对修改和删除有效）。

- 创建有多个执行语句的触发器MySQL格式：

  ```mysql
  create trigger trigger_name trigger_time trigger_event
  	on tb1_name for each row 
  	begin
  		语句执行列表
  	end;
  ```

  begin end:表示触发程序的边界（开始和结束），其中可包含多条语句

  - 例，使用触发器来确保关系section中的属性time_slot_id的参照完整性

    ```mysql
    DELIMITER //
    create trigger timeslot_check1 after insert on section
    		for each row 
            begin
    			if new.time_slot_id not in (select time_slot_id from time_slot) then 			 rollback;
                end if;
            end;
    
    ```

- 删除触发器：

  ```mysql
  drop trigger [schema_name.]trigger_name;
  ```

  schema_name表示的是数据库名称，是可选的，如果忽略了该选项，将从目前访问的数据库中清除触发程序

- 查看触发器：

  ```mysql
  show triggers; # 查看所有触发器
  ```

  ```mysql
  select * from information_schema.triggers where condition; # 在trigger表中查看触发器信息
  ```

  conditon:一般为指定trigger的名字，如：`trigger_name = 'timeslot_check1'`

### 2、数据操纵：

SQL查询语句的通用形式如下：

```mysql
select <[distinct] c1,c2,...>
from <r1,...>
[where <condition>]
[group by<c1,c2,...>] [having<cond2>]
[order by<c1[desc]>,[c2[desc|asc],...]]
```

SQL查询顺序：from —>where —>group —>having —>select —>order

**我们先从主要结构开始学习**

SQL查询的基本结构主要结构如下：

```sql
select A1,A2, ... , A3
from r1,r2, ... , rm
where P
```

上述关系等同于等价关系代数表达式：**П**<font size = 1>A1,A2, ... , An</font>(**б**<font size =1>P</font>(r1**×**r2**×**...**×**rm))

查询的语句的基本顺序是先从from子句中列出关系后（笛卡尔积），再在这些关系上使用where子句进行选择满足条件P的关系集（选择），最后使用select语句对想要展示的属性进行映射。



**例子：**

   - classroom (buiIding, room_ number, capacity)
   - department (dept_ name, building, budget)
   - course (course_ id, title, credits)
   - instructor (ID, name,salary)
   - section (course_ id,sec_ id, semester, year)
   - student ( ID, name,tot_cred)
   - time_slot(time_slot_id,{(day,start_time,end_time)})

**select子句注意：**

- SQL语句不区分大小写，并且select语句的表达式结果是不会去除重复元组的，若想去除重复元组请使用

   `select distinct dept_name from instructor;`,select 后加 distinct。

- 在select后加 * 代表显示所有的属性。`Mysql select * from instructor;`

- 同时在select子句中还可加入含有符号（+、-、*、/）的基本运算符表达式，运算对象可以是常数和属性。如：`select ID,name,salary*1.05 from instructor;`

- 在查询子句的最后加上 order by <属性名> asc|desc 可起到对查询结果排序的作用，asc为正序排序，desc相反

  - 例，按salary的降序列出整个instructor关系，如果几位教师的工资相同，就将他们按照名称升序排列`select * from instructor order by salary desc,name asc;`

**where子句注意：**

- where子句允许我们只选出那些在from子句的结果关系中满足特定谓词（P）的元组
- `select name from instructor where dept_name = 'Comp.Sci.' and salary > 70000;  `这句话等同于找出所有在Computer Science系并且工资超过70000美元的教师姓名(**П**<font size =1>name</font>(**б**<font size = 1>dept_name = 'Comp.Sci.' **^**salary >70000</font>(instructor)))。
- SQL允许在where子句中使用逻辑连词and，or和not，也可使用between指定范围查询。逻辑连词包括（<,<=,>,>=,=,<>）例如：`select name from instructor where salary<=100000 and salary >=9000;`

**from子句注意：**

- from子句是一个查询求值中需要访问的关系列表，通过from子句中定义了一个该子句中所列出关系上的笛卡尔积
- 例如，找出关系instructor和teachers的笛卡尔积`select * from instructor,teachers;`
- 例如，找出Computer Science系的教师名和课程标识`select name , course_id from instructor , teachers where instructor.ID = teachers.ID and instructor,dept_name = 'Comp.Sci.';`

**更名运算注意：**

- SQL提供可为关系和属性重新命名的机制，即使用as子句：`old_name as new_name`，as子句可以出现在select和from语句中。
- **例：**`select T.name as name, S.course_id as course_id from instructor as T,teachers as S where T.ID = S.ID;`，这样的好处在于方便标识结果或引用关系更加简洁。

**字符串运算注意**：

- 对字符串进行的最通常的操作时使用操作符like（在MySQL中时 REGEXP）来匹配。	
  - 百分号%（MySQL中为 *）：匹配任意子串
  - 下划线_（MySQL为 .）：匹配任意一个字符
  - 方便匹配中包含特殊字符，可用escape来定义转义符，如：`like 'ab\%cd%' escape '\'`匹配所有以ab%cd开头的字符串。
  - 具体数据库都不一样，关于详细的操作大家可以上网了解
- 例，找出所有建筑名称包含子串'Watson'的所有系名`select dept_name from department where building like '%Watson%';`

**集合运算注意：**

- 针对不同数据库，数据库对三种集合运算所支持的情况是不同的

- SQL作用关系上的三种关系 union、intersect、except运算对于数学集合中的∪、∩和 - 运算

- 这三种关系运算与select默认的不同，这三种运算是会自动去重的，如果希望保留重复内容，需要用all加在这三种运算后面

- 如果同一个元组在r中出现了m次，在s中出现了n次，那么这个元组将会重复出现：

  - r union s：出现m+n次
  - r intersect all s：出现min（m，n）次
  - r except all s：出现max（0，m-n）次

- 例，找出在2009年秋季开课，或者在2010春季开课或两个学习都开课的所有课程：

  ```sql
  (select course_id from section where semester = 'Fall' and year = 2009)
  union
  (select course_id from section where semester = 'Spring' and year = 2010);
  ```

- 例，找出在2009年秋季开课，但不在2010年春季开课的所有课程：

  ```sql
  (select course_id from section where semester = 'Fall' and year = 2009)
  except
  (select course_id from section where semeter = 'Spring' and year = 2010);
  ```

**分组函数注意：**

- 分组聚集group by，group by 子句中给出的一个或多个属性是用来构造分组的，在group by子句中的所有属性上取值相同的元组将被分在一个组中
- having子句类似于where子句，但只会对分组起到限定作用，而不会对元组限定条件。having子句中的谓词在形成分组后才会起作用，因此可以使用聚集函数
- 例：会在下面的聚集函数中一块举例
- 任何没有出现在group by子句中的属性，如果出现在select子句中的话，它只会出现在聚集函数内部，否则这样的查询是错误的。就好似你用dept_name对instructor分组，得出结果后你不能期望得到分组后老师的姓名或是薪水，应该是得到最大薪水或是平均的薪水。

**聚集函数注意：**

- 聚集函数是以值的一个集合作为输入，返回单个值作为结果，聚集函数分为：

  - 平均值 avg
  - 最小值 min
  - 最大值 max
  - 总和 sum
  - 计数 count
  - 其中，sum和avg的输入必须是数字集，但其他运算符还可以作用在非数字数据类型的集合上，如字符串

- 如果在查询语句中使用了分组查询（group by），那么聚集函数就会对每个分组进行相应的运算，得出的结果也会付给各个分组作为分组后的属性。

- 例，找出Computer Science系教师的平均工资

  ```sql
  select avg(salary) as avg_salary from instructor where dept_name = 'Comp.Sci.';
  ```

  等同与g<font size =1>avg(salary) as avg_salary</font>((**б**<font size =1>dept_name = 'Comp.Sci.'</font>(instructor))

- 例，找出每个系的平均工资

  ```sql
  select dept_name,avg(salary) as avg_salary from instructor group by dept_name;
  ```

- 例，找出平均工资超过42000的系

  ```sql
  select dept_name,avg(salary) as avg_salary from instructor group by dept_name 
  having avg(salary) > 42000;
  ```

**空值注意：**

- 空值代表关系中属性值的信息缺失，在谓词中可以利用is null或是is not null来测试空值或非空值

  - 例，找出在instructor关系中元组在属性salary上取空值的教师名

    ```sql
    select name from instrcutor where salary is null;
    ```

- 聚集函数对空值的处理：

  - 除了count(*)外所有聚集函数都忽略输入集合中的空值
  - 规定：空集的count运算为0，其他聚集运算在输入空集的情况下都返回一个空值

#### 嵌套子查询：

​		SQL提供嵌套子查询机制。子查询是嵌套在另一个查询中的select-from-where表达式。子查询嵌套在where子句中，通常用于对集合的成员资格、集合的比较以及集合的基数进行检查。任何select-from-where表达式返回的结果都是关系，因而可以被插入到另一个select-from-where中任何结果关系可以出现的位置。主要用于：

- **集合成员资格：**SQL允许测试元组在关系中的成员资格。连接词in测试元组是否是集合中的成员，集合由select子句产生的一组值构成的，还有not in。简单说就是，提前做了一个含有一组元素的表，我们要的结果除了要在给定的表里面判断谓词逻辑判断以后，还需要判断自己的某些元素是否被提前做的表包含。

  - 例，找出在2009年秋季和2010年春季学期同时开课的所有课程

    ```sql
    select distinct course_id from section
    where semester = 'Fall' and year = 2009 and 
    course_id in(
        select course_id from section where semester = 'Spring' and year = 2010
    );
    ```

  - 例，找出（不同的）学生总数，他们选修了ID为10101的教师所讲授的课程

    ```sql
    select count(distinct ID)
    from takes
    where(course_id, sec_id, semester, year)
    					in (select course_id, sec_id, semester, year 
                            from teachers
                            where teachers.ID = 10101
                           );
    ```

    

- **集合的比较:**考虑查询“找出满足下面条件的所有教师姓名，他们工资至少比Biology系某一个教师的工资要高”，在前面，我们将此查询写作：

  ```sql
  select distinct T.name from instructor as T,instructor as S 
  where T.salary > S.salary and S.dept_name = 'Biology';
  ```

  - 上面的例子在SQL中提供另一种方式书写上面的查询。短语“至少比某一个要大”在SQL中可用>some()表示。

    ```sql
    select name from instructor
    where salary > some(select salary from instructor where dept_name = 'Biology');
    ```

    <img src="https://i.loli.net/2020/05/13/2FgcynRDsIHNdMf.png" alt="WCTYMPT~C9H2_CE_SCDFEKU.png" width = 600 />

  - 考虑查询“找出满足下面条件的所有教师的性名，他们的工资比Biology系每个教师的工资的都高”，在SQL中，结构>all对应与词组“比所有的都大”，那么

    ```sql
    select name from instructor
    			where salary > all(select salary from instructor where dept_name = 'Biology');
    ```

    <img src="https://i.loli.net/2020/05/13/uTc8ojRVIDiCrML.png" alt="T`_IMT___OD@B14W_R_1S_4.png" width = 600 />

- **空关系测试:**SQL还有一个特性可测试一个子查询的结果中是否存在元组。

  - exists ：exists后面所跟的子查询语句有结果时，返回true

  - not exists：not exists后面所跟的子查询语句没有结果时，返回true，“关系A包含关系B”写成“not exists（B except A）”或“exists（A except B）”

  - 例，找出在2009年秋季学期和2010年春季学期通识开课的所有课程，使用exists结构：

    ```sql
    select course_id
    from section as S
    where semester = 'Fall' and year = 2009 and
    		exists(select * 
                   from section as T
                   where semester = 'Spring' and year = 2010 and
                   S.course_id = T.course_id 
            );
    ```

    这个例子中exists中嵌套的子查询语句包含原查询语句的S（section），这样的结构就非常双重循环语句，对每一个已经满足`semester = 'Fall' and year = 2009`的元组中的course_id再带入到子查询语句中去判断存在与否。这样的结构和子查询**不**引用原查询语句的表名不同，不引用的结构为子查询已经处理完毕而这样的结构还未处理完毕。

  - 在SQL语句中是不存在代数关系中的除的关系，但是可以用exists和not exists代替

    例，找出选修了Biology系开设的所有课程的学生：

    ```sql
    select distinct S.ID,S.name
    from students as S
    where not exists(
    				(select course_id 
        			from course
        			where dept_name = 'Biology'	)
        			except
        			(select T.course_id
                     from takes as T
                     where S.ID = T.ID
                    )
    );
    ```

    思想很简单，就是先找出生物系所有的课程然后对某个学生所选的课程做个差，如果这个差是空的，那么这个学生就选了所有的课程。

- **重复元组存在性测试:**SQL提供一个布尔函数，用于测试在一个子查询的结果中是否存在重复元组。如果作为参数的子查询结果中没有重复的元组，unique结构将会返回true值。

  - 例，找出所有在2009年最多开设一次的课程

    ```sql
    select T.course_id
    from course as T
    where unique(select R.course_id from section as R
                					where T.course_id = R.course_id and R.year =                                       2009);
    ```

  - 例，找出所有在2009年最少开设两次的课程

    ```sql
    select T.course_id
    from course as T
    where not unique(select R.course_id from section as R
                					where T.course_id = R.course_id and R.year =                                       2009);
    ```

- **from子句中的子查询:**SQL允许from子句中使用子查询表达式。

  - 例，找出系平均工资超过42000的那些系中教师的平均工资：

    ```sql
    select dept_name,avg_salary
    from (select dept_name,avg(salary)
         	from instructor
         	group by dept_name) as dept_avg(dept_name,avg_salary)
         	where dept_avg.avg_salary >42000;
    ```

  - 例，找出在所有系中工资总额最大的系：

    ```sql
    select dept_name,max_salary
    from(select dept_name,sum(salary) from instructor group by dept_name)
    as dept_total(dept_name,tot_salary) where max(dept_total.tot_salary) = dept_total.tot_salary;
    
    ```

- **with子句:**with子句提供定义临时关系的方法，这个定义只对包含with子句的查询有效

  - 例，找出具有最大预算值的系

    ```mysql
    with max_budget(value) as (select max(budget) from department)
    select budget from department,max_budget
    			  where department.budget = max_budget.value;
    ```

#### 数据库的修改-删除：

**例：**从instructor关系中删除所有这样的教师元组，他们位于Watson大楼的系工作

```sql
delete from instructor where dept_name in(select dept_name from department where building = 'Watson')
```

**例：**删除工资低于大学平均工资的教师记录

```sql
delete from instructor where salary < (select avg(salary) from instructor);
```

**例：**假设我们要插入的信息是Computer Science系开设的名为“Database Systems”的课程CS-437，它有4个学分

```sql
insert into course values('CS-437','Database Systems','Comp.Sci.',4);
```

若上述的某些属性允许为null，也可插入null值

**例：**同时我们也可以在insert语句中指定属性，上述还可写为：

```sql
insert into course(course_id,title,dept_name,credits) 
values('CS-437','Database Systems','Comp.Sci.',4);
```

**例：**我们也可以插入多条记录

```sql
insert into course(course_id,title,dept_name,credits) 
values('CS-324','Java program design','Comp.Sci.',3),
	  ('CS-437','Database Systems','Comp.Sci.',4);
```

**例：**我们想让Music系每个修满144学分的学生成为Music系的教师，其工资为18000

```sql
insert into instructor
select ID,name,dept_name,18000
from students
where dept_name = 'Music' and tot_cred>144;
```

#### **数据库的修改-插入：**

**例：**假设给工资超过100000美元的教师涨3%的工资，其余涨5%

```sql
update instructor 
set salary = salary*1.03
where salary > 100000;
update instructor
set salary = salary*1.05
where salary <= 100000;
```

**例：**假如上面两个语句执行反了，可能会引起某些教师二次执行涨工资的误操作问题，因此我们需要用SQL提供的case结构来避免更新次序引发的问题，结构如下：

```mysql
case
when pred1 then result1
...
when predn then resultn
else result0
end
```

```mysql
update instructor
set salary = case
			 when salary <= 100000 then salary*1.05
             else salary*1.03
end;
```



### 3、数据控制：

在接触数据控制语句之前我们先了解一下数据库管理系统的安全

#### 数据库系统安全：

   主要目的是为了防止而已更新或者是偷窃数据的企图

- 数据库系统级：
  - 通过**验证**和**授权**机制使得特定用户存取特定数据，避免不应该接触到数据库的用户恶意篡改与拷贝数据
  - 这也是这一节主要的内容
- 操作系统级：
  - 操作系统的超级用户可以对数据库做出任何事情，一个好的操作系统级的安全机制对数据的安全是非常重要的
- 网络级：使用数据加密
  - 偷听（非授权的读取信息）
  - 伪装（冒充授权用户）
- 物理级：
  - 对计算机的物理访问使得入侵者可以摧毁数据，需要传统的手段解决
  - 防止洪水，火灾等对计算机的损坏
- 人员级：
  - 审查用户以确保授权用户不会将存取权限给入侵者
  - 训练用户选择口令与保密



该小节主要是讲解数据库中常用的授权机制与语句。

**数据授权的种类：**用户被赋予对数据的权限主要包括以下几类

- 读权限：允许读，但不允许更新数据
- 插入权限：允许插入新数据，但不允许更新现有数据
- 修改权限：允许修改，但不允许删除数据
- 删除权限：允许删除数据

**数据库模式的授权：**

- 索引权限：允许创建和删除索引
- 资源权限：允许创建新关系
- 修改权限：允许增加或删除关系属性
- 删除权限：允许删除关系

**授权与视图：**将视图授权给部分用户的优点

- 用户可被授予关于视图的权限，而不被授予关于该视图定义中涉及的关系的权限

- 视图隐藏数据的能力技能简化系统的使用又能增加安全性（只允许用户存取他们工作中需要的数据）

- 关系级安全性与视图级安全性的结合使用可精确地将用户存储限制在他所需要的数据库上

- 例，一个工作人员只需要知道一个给定的系（比如Geology系）里所有员工的工资，但是无权看到其他系中员工的相关信息。

  - 不对instructor关系直接访问，但授予对视图geo_instructor的访问权限，该视图仅属于Geology中的那些instructor元组构成,最后再将这个视图授权给相应用户就可以解决该问题

    ```mysql
    create view geo_instructor as(
        select * from instructor where dept_name = 'Geology'
    );
    ```

**授权图：**权限从一个用户到另一个用户的传递可用授权图表示，改图的各个节点表示为用户，跟节点为数据库管理员（root 用户），Ui —>Uj表示用户Ui将某权限授予给了用户Uj。

<img src="https://i.loli.net/2020/05/16/wdtJTSvxXAuZcal.png" alt="SD_X0_7LK__UEFP3LSR6TWS.png" width = 600 />

- 授权图中的所有边都必须是某条从数据库管理员出发的路径的一部分
- 若DBA要从U1取回权限，那么就必须要收回U4的权限，因为U1不再有权限。不能收回U5的权限，因为U5还被DBA的某条路径直连

**SQL中的安全性声明：**

- 在SQL中一般的授予语句格式为`grant <privilege list> on <relation name pr view name> to <user list>;`授予权限者自身必须就具备相应的授予权限，比如在SQL中需要具备`with grant option`这样的语句来保证自己可以授权自己的权限，在SQL中的权限授予可以精确到列，如select（sname）

- user list:可以是用户ID、public代表所有合法用户,角色

- privilege list：权限类型，其中包括（这些只是最基本的，感兴趣可以自己查阅）

  - select
  - insert
  - update
  - delete
  - references
  - all privileges:所有权限
  - with grant option:允许用户把被授予大的权限再转授给其他用户
    - 比如，授予U1对instructor的select权限并允许U1将此权限授予其他用户`grant select on instructor to U1 with grant option;`

- user list:被授权者，包括用户，角色

  - 用户：是需要被创建的，如创建一个用户名为Jeffrey的本地用户，密码为mypass ，`create user 'Jeffrey'@'localhost' identified by 'mypass'`。

  - 角色：角色可以针对一类用户指定共有的权限，如同针对用户一样可以对角色授予或是回收权限，角色可被赋予用户甚至是其他角色。

    - ```mysql
      create role instructor;
      grant select on takes to instructor;
      grant instructor to USER1;
      create role dean;
      grant instructor to dean;
      grant dean to USER2;
      ```

- SQL中权限的回收：`revoke <privilege list> on <relation name  or view name> from <user list> [restrict|cascade]`

  - 例如：`revoke select on instructor from U1,U2,U3 cascade;`

  - 从以用户收回权限可能会导致其他用户也失去权限，称为级联回收，使用restrict可以阻止级联回收

    例如：`revoke select on instructor from U1,U2,U3 restrict;`

  - 如果同一权限被不同授予者两次授予同一用户，那么该用户在回收一次后仍保持该权限



#### 审计跟踪(audit trail):

​		审计跟踪是关于应用程序数据的所有更改该的日志，以及一些信息，如哪个用户执行了更改和什么时候执行的更改。使用触发器也可以实现审计跟踪，但目前很多数据库提供了内置的机制创建审计跟踪。

## **<a name="第四章">第四章：ER图</a>**

​		E-R模型的概念在第一章已经描述过了，这里就不赘余了，该章主要目的为讲述E-R模型的设计方法，以及E-R模型和表的转换。

### 1、E-R模型中的概念及表示：

#### 实体集：

​		**实体**是客观存在的对象并且和其他对象可区分（比如：特定的人，公司），实体是具有属性的（人具有姓名和住址）。**实体集**就是相同类型的实体的集合，他们具有共同的性质（所有人的集合，所有公司的集合）。

<img src="https://i.loli.net/2020/05/17/2MNgALczCKqYEnv.png" alt="A_Q@MLP__5_7D_~`SE9~JSA.png" width = 600/>

​		**实体**是由一个**属性集合**（比如上面的ID、name、dept_name、salary）来表示，这些属性集合是实体集中的所有成员都具有的描述性特征。**域**就是属性允许取值的集合。



**属性的种类：**

- 简单属性和复合属性（洋人的fist_name和last_name单个看可视为简单属性，而name是两个简单属性的集合视为复合属性）
- 单值属性和多值属性（某个老师具有的电话号，如果数据库设计时只考虑一个电话号，就是单值属性。否则为多值属性）

#### 联系集：

​		**联系**是指多个实体之间相互的关联，比如老师和学生之间的关联，一个老师可能会教导多个学生，但一个学生可能只被一个老师教导。**联系集**是相同类型联系的集合，一个联系集包含多个同类联系（或联系实例，relationship instance），一个联系集表示两个或多个实体集之间的关联。

<img src="https://i.loli.net/2020/05/17/ANfLHJZtp1u6wIG.png" alt="2_QQ1BYCZA2_U_I_4YJ2@PJ.png" width = 600 />

<img src="https://i.loli.net/2020/05/17/XgoyeR9TtZSrcdC.png" alt="HEX@YSL_1_W2L_0X_EMSZ_W.png" width = 600 />

严格用数学的定义来说，联系集是n>=2个实体集上的数学关系，每个实体取自一个实体集

- {(e1,e2,...,en)|e1∈E1，e2∈E2,...,en∈En},(e1,e2,...,en)是一个联系，Ei为实体集
- 如：(98988,76766)∈advisor,其中，98988∈student,76766∈instructor

联系集本身也可以具有属性，比如instructor和student之间的advisor联系集就可具有属性date,来表示某学生是什么时候变为某导师的学生。advisor(s_ID,i_ID,<font color = red>date</font>)

<img src="https://i.loli.net/2020/05/17/Cu24aAIovJMBpZt.png" alt="_CR2B_9X_5@_Z_BJGIP_R85.png" width = 600 />

**联系集的度：**参加联系的实体集的个数n，称为联系集的度(n元联系)。一个联系集一般包含两个实体集（很少会多于两个实体集），但在某些情况下联系集会包含多余两个的实体集。

如，假设一个student在每个项目上最多只有一位导师，如下图，包含三个实体机instructor、student和project(三元联系)

<img src="https://i.loli.net/2020/05/17/wp4WG75nmbdAqz9.png" alt="AIYOJ7K7YIYRM_D82L`__~A.png" width = 600/>

**映射基数：**表达一个实体通过联系集进行关联的其他实体的个数

- 一对一：总统和国家
- 一对多：年级和学生
- 多对一：病人和医生
- 多对多：学生和课程

**码**：在联系集中的属性一般都会选用其中关联的各实体集的主码的组合作为自己的超码。当然联系集的候选码依赖于联系集的映射基数（1:1,1:n,m:n）

#### E-R图的画法：

现在使用的E-R图大多为六代或者是五代，两者虽然部分不同，但是总体是一致的，这里介绍第六代的画法。

<img src="https://i.loli.net/2020/05/17/M9ubg8WSc3KvtFh.png" alt="Q@1_AV__7AH1F0`T`CN_1_L.png" width = 400 />

<img src="https://i.loli.net/2020/05/17/7hl9JtOXpKwEGMN.png" alt="U2BDR6XF2_PT13RPX_DP8UX.png" width = 500 />



- <font color = red>分成两部分的矩形</font>代表实体集。有阴影的第一部分包含实体集的名字，第二部分包含实体集中所有属性的名字

- <font color = red>菱形</font>代表联系集

- <font color = red>未分割的矩形</font>代表联系集的属性。构成主码的属性以下划线标明

- <font color = red>线段</font>将实体集连接到联系集

- <font color = red>虚线</font>将联系集的属性连接到联系集

- <font color = red>双线</font>实体集中的每个实体都至少参加了联系集中的一个联系

  如下图，表示section中的每个实体都参与到了sec_course的联系集当中

  <img src="https://i.loli.net/2020/05/17/tmpqIbDYXHCn4fW.png" alt="J3SSO46NIJQN`28M_`_Z@CJ.png" width = 500/>

- <font color = red>带箭头的线段</font>表示被箭头指向的实体集中的实体对另一个实体集中的实体是一对多的联系

  如下图就是一种一对多的联系：

  <img src="https://i.loli.net/2020/05/17/HTXWIcqZ9KPuYOM.png" alt="3_T`4S_~LTF_4_D96_EMIHG.png" width = 500 />

- <font color = red>双菱形</font>代表连接到弱实体集的标志性联系集。**弱实体集**：不具有主键的实体称为弱实体集，比如下面的section的sec_id就依赖于course的course_id。

  如下图，section对course有依赖性，因此section是一种弱实体集，并且该若实体集总是全部参与到联系中的

  <img src="https://i.loli.net/2020/05/17/tmpqIbDYXHCn4fW.png" alt="J3SSO46NIJQN`28M_`_Z@CJ.png" width = 500 />

- <font color = red>复合或多值属性</font>

  <img src="https://i.loli.net/2020/05/17/he4xpZQrBNRjVtk.png" alt="PMTL5CO_KKL_F0J_`_41CPC.png" width = 500 />

**非二元联系与二元联系：**

很多的非二元联系都可以用二元联系更好的表示，方法是人为的创建一个实体集

- 将实体集A,B,C之间的联系R用实体集E和以下三个联系集代替：
  - RA，将E与A关联
  - RB，将E与B关联
  - RC，将E与C关联
- 为E创建一个特殊的表识属性（可以是主码），并将R中的所有属性都加给E
- 对R中的每一个联系集（ai,bi,ci）
  - 创建实体集E中的每一个新实体集ei
  - 将(ei,ai)加入到RA
  - 将(ei,bi)加入到RB
  - 将(ei,ci)加入到RC

<img src="https://i.loli.net/2020/05/17/stHzVXSLOqmaJdU.png" alt="ECCTULA0_D0V_`A_T_ENVP7.png" width = 500/>

#### **扩展的E-R特性：**

**特化：**

- 自顶向下的设计过程中，确定实体集中的一个具有特殊性质的子集

- 这些子集称为低层实体集，它们具有特殊的属性或者参加特殊的联系

- 属性继承：低层实体集继承它连接的高层实体集的所有属性及参加的联系

- 特化用从特化实体指向另一方实体的空心箭头来表示。这种关系为ISA关系，代表“is a”（是一个）。例如，一个教师“是一个”雇员

  <img src="https://i.loli.net/2020/05/17/1yzeASM8qNY7Pxn.png" alt="K_YSLJ8N@_82SX99G7OBJKW.png" width = 500 />

这个图也可以这么画（老版画法）：

<img src="https://i.loli.net/2020/05/17/uwiZo6kOEJYIr7a.png" alt="4_4ADM5K_TRS2Y73_0~ZE@Q.png" width = 300 />

**概化：**

- 自底向上设计过程中，将若干共享相同特征的实体集组合成一个高层实体集
- 特化与概化互逆，它们在E-R图中以相同的方式表示

**对特化/概化的设计约束：**

- 关于哪些实体可以是给定低层实体集的成员约束
  - 条件定义的
    - 只有满足student_type = "研究生"的实体才允许属于graduate_student实体（undergraduate_student和graduate_student都“isa”student）
  - 用户定义的
    - 大学雇员属于不同的工作组
- 关于实体在单个概化中是否可以属于多于一个低层实体集的约束
  - 不相交
    - 一个实体只属于一个低层实体集
    - 在E-R图中ISA加上单词"disjoint"（老版，新版不用，新版在重叠的加total）
  - 重叠
    - 一个实体可以属于多个低层实体集
- 完备性约束：说明高层实体集中的实体是否必须至少属于一个低层实体集
  - 全部概化或特化：每个高层实体必须属于一个低层实体集
  - 部分概化或特化：允许一些高层实体不属于任何低层实体集

#### E-R图画法总结：

**新版：**

<img src="https://i.loli.net/2020/05/17/IkgbPm8cVsfAWSK.png" alt="_U___OMMMV~YKB19@YSBE53.png" width = 500 />

<img src="https://i.loli.net/2020/05/17/XHpQoSvFJZ4jUIM.png" alt="H5_M_2T4S_FXVRM__06J32I.png" style="zoom:50%;" />

**老版：**

<img src="https://i.loli.net/2020/05/17/fTu8WvVpDdyw4bt.png" alt="3I`TBIAT02AQ1V0_E_Z_UEE.png" width = 500 />

<img src="https://i.loli.net/2020/05/17/tGbh6NasniHUoDp.png" alt="0X6C_CXA0RM_K960O~XA_RP.png" style="zoom:50%;" />

### 2、使用E-R模式设计数据库：

**以下几个步骤：**

- 需求分析
  - 需要什么样的数据，应用程序和业务
- 概念数据库设计
  - 使用E-R模型或类似的高层次数据模型，描述数据
- 逻辑数据库设计
  - 将概念转换为某个DBMS所支持的数据模型
  - 关系标准化，检查冗余和相关异常关系结构(下一章)
- 物理数据库设计
  - 索引，集群和数据库调优

<img src="https://i.loli.net/2020/05/17/dBNwrx6VvYARL34.png" alt="I5T6SIB0IGP081_RPG_6_P0.png" width = 500 />

<img src="https://i.loli.net/2020/05/17/zkXjOtVCsbnHPyf.png" alt="DVCB67S6KTHV__E8YON~X`T.png" width = 500/>

#### **E-R设计决策最好考虑下面的原则：**

- **用属性还是实体集来表示对象：**属性和实体集都是用来表示对象的形式

  - 若一个对象只对其<font color = red>名字</font>及单值感兴趣，比如性别；若一个对象除了名字外本身<font color = red>需要其他的属性</font>来进行描述，那么对象应该定义为实体集。
  - 一个对象不应该同时作为实体和属性
  - 一个实体集不能与另一实体集的属性相关联，只能实体和实体相联系（对象与对象应该是同等的，除非这个属性能够代表另一个实体也就是候选码,或者这些个属性能够直接组合代表另一个对象）

- **选择实体集还是联系集：**

  - 如果是两个对象之间发生动作，那么这个动作应该用**联系集(relationship set)**来表示

  - 选用联系集后应该考虑映射基数的影响。如，当一个客户在一个分支机构有多个贷款账户，那么就会影响E-R图的设计

    <img src="https://i.loli.net/2020/05/17/P3vXRbwZNBQjM1D.png" alt="_EG3CGGER_XC7Q_9SWRGCN1.png" width = 500 />

- 用实体属性还是用联系

  - 比如student(sid,name,sex,age,...,supervisor-id,supervisor-name,supervoisor-position,...,class,monitor)

  - 这时就应该从对象的独立性和减少数据冗余上考虑

    student(sid,name,sex,age,...);

    supervisor(sup-id,name,position,...);

    stu-sup(sid,sup-id,from,to);

    class(classno,specialty,monitor,stu-sum);

    stu-class(sid,classno);

- 用n元联系还是二元联系

- 用强实体集还是弱实体集

- 特化/概化的使用，有助于设计的模块化

- 聚集的使用，将聚集实体集视为单个单元，从而不必关心其内部结构的细节

#### 例、大学数据库的设计：

1. **获取系统需求**：

   - classroom,department,course,instructor,section,student,time_slot

2. **实体集设计：**

   - classroom (buiIding, room_ number, capacity)
   - department (dept_ name, building, budget)
   - course (course_ id, title, credits)
   - instructor (ID, name,salary)
   - section (course_ id,sec_ id, semester, year)
   - student ( ID, name,tot_cred)
   - time_slot(time_slot_id,{(day,start_time,end_time)})

3. **联系集设计：**

   - inst_ dept:关联教师和系
   - stud_ dept :关联学生和系
   - teaches:关联教师和开课
   - takes:关联学生和开课，包含描述性属性grade
   - course_ dept: 关联课程和系
   - sec_ course:关联开课和课程
   - sec_ class:关联开课和教室
   - sec_ time_ slot: 关联开课和时段
   - advisor:关联学生和教师
   - prereq:关联课程和先修课程

4. **E-R图：**

   <img src="https://i.loli.net/2020/05/17/4AKMjadzVrhnvRq.png" alt="F61BZD0HE6~_V7~KX_YDV_A.png" width = 1000 />

### 3、E-R图与表：

**将E-R模式转换为数据表：**

- E-R转换成表格格式是E-R图导出关系数据库设计的基础
- 符合E-R图的数据库可以表示成若干表的集合
- 对每一个实体集及联系集都有一个唯一的表，该表的名字就是对应实体集或联系集的名字
- 转化也就是上一章所说的建表语言，各个数据库都有不同



**实体集表示为表：**

- 强实体集转换到具有相同属性的表

  <img src="https://i.loli.net/2020/05/17/aD4Ul69KE8osGpA.png" alt="D03Q~O_9LD_GQDZN6NUBEZQ.png" width = 500 />

- 复合属性可通过为每个组成属性创建一个单独属性

  - 例，对符合属性name（组成属性为first-name和last-name）的实体集instructor，对应的表具有两个属性first-name和last-name

- 实体集E的多值属性M用一个单独的表EM表示

  - 例，instructor的多值属性phone_number表示为表

    instructor(ID,name,salary,phone_number)——>

    ​																						instructor(ID,name,salary)

    ​																						instructor_phone(ID,phone_number)		

  - 将多值属性的每个值映射到表EM中的单独行

    - 主键为"22222"的instructor实体及其电话号码"555-1234"和"555-4321"映射到instructor_phone中

      (22222,555-1234)和(22222,555-4321)

- 弱实体集转换成的表还包含对应于其标识强实体集的主键的列(外键)

  <img src="https://i.loli.net/2020/05/17/o7uYLBvJz1ltc5x.png" alt="LR5429G`QGQE1E_MZ_CJ0_E.png" width = 500/>

- 联系集表示成的表具有对应于两个（或多个）参加实体集的主键的列，以及对应于联系集自己的描述性属性的列

- 关于多对一的联系表，我们只需要规定"多"的属性为主键就OK了

  - 如果多对一和一对多联系集在”多“端是完全的，则不必为联系集创建表而是在对应于”多“端的表中加入对应于"一"端的主键大的额外属性
  - 如果”多“端参加联系时部分的，上述方法会导致空值

- 联系实体集及其标识性实体集的联系集对应的表是冗余的（E-R图上有，建表时不必）

- 特化表示成表

  - 方法一：

    - 为高层实体集构造表

    - 为每个低层实体集构造表，包括高层实体集的主键和局部属性

      <img src="https://i.loli.net/2020/05/17/i5wrVamyknHNLCd.png" alt="GU1D`S6NBAK_7_5HHV6_FSA.png" width = 500 />

    - 缺点：访问employee之间的实体的信息需要访问两张表

  - 方法二：

    - 为每个实体集构造表，其属性包括所有局部属性和继承来的属性

      <img src="https://i.loli.net/2020/05/17/BryZpk9sJhAoV1a.png" alt="_G4~F4QEFXFX4O12H_A_LF1.png" width = 500 />

    - 如果关系是全部特化，那么没必要为一般实体person创建表（当不需要外键约束时）

      - 对于person也可以定义为包含特化关系的”视图“

    - 缺点：对于又是学生又是雇员的人，其name、street和city冗余

### 例：

​	学生学习某门课程。每个学生都有学号，姓名，年龄和性别属性。每门课程都有课程编号，课程名，学分和上课教室编号属性。每个学生可以是本科生或研究生。对于每一一个本科生，我们想记录他/她的学习年份，平均绩点，以及(可能是多个)电子邮箱。对于每一个研究生，我们要记录他/她的导师的名字，以及(可能是多个)电子邮箱。此外，每门课程有一名研究生作为课程助教，我们要记录助教的开始和结束时间(例如，开始于2015年3月10日，结束于2015年6月30日)。绘制E-R图。

<img src="https://i.loli.net/2020/05/17/yAf6mrT8pD4d5Hs.png" alt="V~MIXB@9_N_`05_L@D7W_RF.png" width = 500 />



## **<a name="第五章">第五章：函数依赖和关系模式分解</a>**

### 1、如何设计一个好的关系数据库：

​		上一章我们已经介绍了如何设计一个数据库，那么如何评价一个关系模式是“好”的呢，这就需要我们对数据库的关系模式调优。当然在了解一个“好”的关系模式之前，我们应该先了解一个“坏”的关系模式。

**“坏”的关系模式：**一个坏的设计模式可能会导致

- 数据冗余
- 插入，删除，修改异常（数据的不一致）
- 假设我们将instructor模式和department模式结合到了一起，用inst_dept(ID,name,salary,dept_name,building,budget)代替了前两个模式。
  - 这就会导致很多的问题，如：
    - 数据的冗余，每个系的dept_name,building,budget数据都要重复一遍，十分浪费空间
    - 数据不一致（搞不好谁插入数据的时候本来应该同一系插入相同的属性（起码building和budget要相同吧），但是搞错了，这就会使得数据不一致）
    - 更新异常，更新会导致数据不一致得问题，正如上面所说的，更新一个元组，就要将逻辑上相同的元组全部更新一遍
    - 插入/删除异常，存储一个还不知道所在系的教师信息，要用null来表dept_name,building,budget，这样是可行的，但是同样null值是难以处理的
    - <img src="https://i.loli.net/2020/05/18/zT3IEqWt6pPA1iG.png" alt="GPLLG8`UFC0_~Z~UJ0K9_A6.png" width = 500 />



​	所以综上所述，我们不是时刻都能保证设计出一个“好”的关系模型，那么万一我们设计出了上面的关系模型怎么办？这就需要有一套理论体系来确保和解决我们设计的“坏”的关系模型转变成“好”的设计模型。

- 数据依赖理论
- 关系范式理论
- 模式分解理论
- <img src="https://i.loli.net/2020/05/18/pnXHeFwZQdOhvKN.png" alt="RIZDN3CRZ7X_5HC@TCGB_G8.png" width = 500 />
- 上面那张图，就可以说是概括了这套理论体系，设计的数据库越靠近中心就越符合标准，但是一般到3NF就足够了。



### 2、数据依赖理论：

#### 函数依赖：

​	设R是一个关系模式，并且有属性集a⊆R，b⊆R使得<font color = red>函数依赖a→b</font>在R上成立，当且仅当对任意合法关系r（R）（这里说的就是关系R上的元组），若r的任意两条元组t1和t2在属性集a上的值相同，则它们在属性集b上的值也相同。即t1[a] = t2[a]   =>  t1[b] = t2[b]，称之为b函数依赖于a，a函数决定b。

在关系模型设计的时候，我们不仅仅是需要一个对象中的属性，我们还需要这些属性之间的的函数依赖(比如说student的sid能够决定sname)

<img src="https://i.loli.net/2020/05/18/dvSra3DxscLU854.png" alt="_C_KX_A2R`R7C6_2VLV@@_3.png" width = 200 />

如上图，α→β，

<img src="https://i.loli.net/2020/05/18/qbN7ID1k9xRHXuK.png" alt="_CEPA0_3_9CW_X_6Q_IN_P9.png" width = 200 />

如上图，A→B不成立，但是B→A（B中都没重复的自然就成立了）



以下概念涉及到码的概念，忘记或不懂得推荐看<a href="#第二章">第二章</a>，开头部分

**超码：**函数依赖是码概念的推广，若K是关系模式R的**超码**当且仅当**K→R**（K能够唯一的标识在这个关系模式下的某个元组）

**候选码：**K是R的候选码当且仅当，K→R并且没有a⊂K（a是K的真子集），使得a→R。（候选码是超码，但是不可再分为超码，最小的超码）

函数依赖的概念虽然是码概念的推广，但是更加灵活也更能丰富表达我们期望的逻辑设计。

**如:**模式inst_dept(<u>ID</u>,name,salary,<u>dept_name</u>,building,budget),我们希望dept_name→building,ID→building而不是dept_name→salary。

#### 第一范式：

​		**第一范式：**如果关系模式R中的所有属性的域都是**原子**的，那么就称R是属于第一范式（1NF）

​		**原子：**如果某个域中元素被认为是不可分的，那么就称这个域是原子的。（非原子的反例：复合属性、多值		属性）

 **函数依赖的用途：**

- 检查关系在给定函数依赖下是否合法：若关系r在函数依赖集F下是合法的，则称r满足F（这个好判断）
- <img src="https://i.loli.net/2020/05/18/xY4D6lrnvwVWy2Z.png" alt="CX7_KXE_B__4CX_LU~_L_Q0.png" width = 500 />
- 对合法关系集合指定约束：如果R上的所有合法关系都满足F，则称F在R上合法（这个不好判断）

**函数依赖的特性**：

- 对X→Y ,但Y⊄X,则称X→Y为**非平凡的函数依赖**;
  - **平凡函数依赖：**被所有关系实例都满足的函数依赖称为平凡的
    - 例，A→B，AB→A，（ID,name）→ID，ID→ID
- 若X→Y ,则任意两个元组,若X上值相等,则Y上值必然相等,则称X为决定因素；
- 若X→Y , Y→X,则记作X↔Y ;
- X→Y ,有基于模式R的,则要求对任意的关系r成立;有基于具体关系r的，则要求对某一关系r成立 ;
- 若一关系r的某属性集X，r中根本没有X.上相等的两个元组存在,则X→Y恒成立
- 若X→Y， Y→Z那么X→Z；

**Armstrong公理**：α、β和γ都是关系R的属性集

- 自反律：若β⊆α，那么α→β（基本）
- 增补律:   若α→β，那么γα→γβ（基本）
- 传递律:   若α→β且β→γ，则α→γ（基本）
- 合并律：若α→β与α→γ成立，那么α→βγ成立（α→β增补γ，α→γ增补α后传递得到的）
- 分解律：若α→βγ成立，那么α→β和α→γ成立（和上面互逆）
- 伪传递律：若α→β与βγ→δ成立，那么αγ→δ成立（α→β增补γ后传递βγ→δ得到的）

**函数依赖集的闭包：**

- **逻辑蕴含：**给定函数依赖集F，存在其他函数依赖被F**逻辑蕴含**

  - 如，F中有A→B且B→C，那么可以推出A→C，那么A→C就被F逻辑蕴含
  - 如，根据平凡函数依赖推导的函数
  - 如，根据**Armstrong公理**推导的函数都是（其实上面两个就是根据Armstrong公理得到的） 

- 被F**逻辑蕴含**的全体函数依赖的集合称为F的闭包，用F+来表示

  - 如，F={A→B，B→C}，F+ ={A→B，B→C，A→C，A→A，AB→A，AB→A，AB→B，AC→C，A→BC，...}

- 例如，R = (A,B,C,G,H,I） F = {A→B , A→C , CG→H , CG→I , B→H} 

  - 得到F+中的一些成员
  - A→H:根据传递规则，A→B和B→H得到
  - AG→I:由G增补A→C得到AG→CG，再由CG→I根据传递规则得到
  - CG→HI:由CG→H和CG→I，根据“合并率”得到

- 计算函数依赖集F的闭包的过程：

  - ```
    F+ = F
    repeat
    	for each F+中的函数依赖f
    			对f使用自反率和增补律
    			将结果函数依赖加入F+		//毫无疑问的根据Armstrong公理得到的逻辑蕴含函数
    	for each F+中的一对函数f1和f2		
    			if f1和f2可以使用传递律结合起来
    				将结果函数依赖加入F+
    until F+不再变化
    ```

    由于包含n个元素的集合含有2^n个子集，因此最多会有可能2^n*2^n个可能的函数依赖

**如何判断集合α是否是超码：**

- 第一种方法：计算F+，在F+中找出所有的α→βi，检查{β1，β2，β3，...} 是否和R相同，若相同就是超码（判断所有可以被α决定的属性的并集是否是整个关系的属性）

- 第二种方法：计算α的闭包，上一个方法的简化方法，只找相关属性忽略不相关的

  - 给定一个属性集α，在函数依赖集F下由α函数决定的所有属性的集合为F下α的闭包（记为α+）

    - 检查函数依赖α→β是否属于F+ <=> **β⊆α+**
    - 判断α是否是超码：α→R属于F+  <=> **R ⊆ α+**

  - 计算α+的算法：思想就是根据α或α的子集以及α子集能决定的属性合并起来继续找能够决定的属性，反复这样进行，直到result不再发生变化

    ```
    result := α;    //α肯定能决定他自己，下面的任务就是看看α最多能决定多少属性
    while(result变化) do	// 当没变化时，就是α能决定的最多属性
    	for each β → γ in F do // 下面这几句都是在讲α在F中根据Armstrong公理能够决定的所有属性
    		begin
    				if β ⊆ result then result := result∪γ
    		end
    	α+ := result // α能决定的最多属性
    ```

  - **例，**R = （A,B,C,G,H,I）F = {A → B,A → C,CG → H,CG → I,B → H} ,问AG是否是R的超码，AG是候选码么

    根据上面的计算方法来计算：**(记住，在result集合中的子集，这些子集推出来任何新属性再重新并入到result中，直到result不变，或者包含全部R中的属性为止)**

    result = AG

    result = ABCG（根据，AG→A ，A→B，这时A⊆result，result∪B = AGB，对于A→C也是同理）

    ​							(也可视为AG→A，A→B，那么AG→B，result∪B = AGB，这其实就是一个传递过程)

    result = ABCGH(ABCG→CG,CG→H，result∪H)

    result = ABCGHI（ABCGH→CG，CG→I，result∪I）

    AG能够决定R，AG是超码

    AG的真子集为A和G

    **A+运算：**

    ​				result1 = A

    ​				result1 = ABC（A → B result∪B,A → C result∪C）

    ​				result1 = ABCH (B → H , result∪H)

    ​				result1 = ABCH （整不出新活儿了）,其实我们可以很理智的看出A			是决定不了G的，因为F的右边压根就没出现过G，A怎么也决定不了G，而且必须要有G			才能推出I，同样I也不能被A决定

    **G+运算：**

    行了不用看了，A同样没在右边出现，G永远到达不了

    因此AG是候选码

  - **例**，R=（A,B,C），F = {A → C，BC→A}，R的候选码是什么

    像这种问题，我们要找候选码就从最小的部分开始，因为如果最小的部分都是超码了，那包含这部分的组合也没必要去找了，肯定不是候选码

    A：A决定不了B

    B：B决定不了C和A

    C：C谁都不行

    AB：A→C，result = ABC

    BC：BC→A，result = ABC

    AC：B只在左边，没在右面出现过，AC只能最多决定他自己，他不是

    候选码：AB,AC

  - 同样的根据该算法，我们不仅可以测试超码和候选码，也可以对函数依赖进行测试（α→β，和超码测试方法一样计算α+，最后看β是否在里面就行了）

#### 正则覆盖：

​		当我们规定了F后，DBMS总是会检查确保数据库的更新不会破坏任何函数依赖。但是如果F过大，那么插入更新的开销就会很大。而有时我们给定的F并不一定是最简的，很多函数都是被已有函数逻辑蕴含的，因此我们需要简化函数依赖集

​		简单说，F的**正则覆盖**(Fc)是指与F等价的“极小的”函数依赖集合

- Fc中任何函数依赖都不包含无关属性

   - Fc中函数依赖的左半部分是唯一的
     			- 如，a1→b1，a1→b2，改写为a1→b1b2

**哪些是F中的多余属性：**

- 函数依赖集中存在可由其他函数依赖推导出的**函数依赖**
  - 例，F={A→C，A→B,B→C},这其中A→C就是冗余的
- 函数依赖的左半部分存在**属性冗余**
  - 例，F = {A→B,B→C,AC→D}A都能决定C了，还用告诉我AC能决定D么，直接A→D就行了
- 函数依赖右半部分存在**属性冗余**
  - 例，F = {A→B，B→C，A→CD}，A→C一眼就可以得出，A→CD也可以分解为A→C和A→D，这个A→C就很多余去掉就行，因此在A→CD中，属性C是多余的

**检测无关的属性：**

- 左半部分的无关属性：

  - 如果A∈α并且**F逻辑蕴含**F<sup>，</sup> = (F - {α→β})∪{(α - A)→β }，那么就称A再α中是无关的
  - 例，F = {A → C，AB → C }中F<sup>，</sup>  = {A→C}∪{A  → C }，可知F逻辑蕴含 F<sup>，</sup>，因此B在AB → C中是无关的

- 右半部分的无关属性：

  - 如果A∈β并且F<sup>，</sup> = (F-{α→β})∪{(α → (β-A) }**逻辑蕴含F**，那么属性A在β中是无关的

  - 例，给定F = {A → C，AB → CD} ，F<sup>，</sup>= {A→C}∪{AB→D}，A → C增补AB→CB，AB→CB和AB→D合并

    AB→CBD，AB→CBD分解AB→CD，所以F<sup>，</sup>逻辑蕴含F，因此C在AB→CD中是无关的

- 检测A∈α在α中是否无关（α = {Aα<sup>，</sup>}，{Aα<sup>，</sup>}→β。若F蕴含α<sup>，</sup>→ β，那么A多余。故只需证明β∈（α<sup>，</sup>）+）

  - 计算F下的（α - {A}）+
  - 检查(α - {A})+是否包含β。若是，那么A就是无关的
  - 也就是说我在α 中不要A了，我根据旧的F照样能决定β，那么A就是无关的

- 检测A∈β在β中是否无关

  - 计算 F<sup>，</sup> = (F-{α→β})∪{(α → (β-A) }下的α+
  - 检查α+是否包含A。如果是，那么A就是无关的
  - 也就是说β中不要A了，我根据这个新的F<sup>，</sup>我照样能决定A



##### 计算F的正则覆盖：

- ```
  repeat
  	对F中依赖利用合并规则		//不要一样的左半部分，要有就要一个
  	α1→β1和α1→β2替换成α1→β1β2
  	找出含有无关属性的函数依赖α→β（在α和β中）  //用上面的检测无关的方法去除，其实一般一眼就										         // 能看出来
  until F不再变化	
  ```

- 例，R = (A,B,C) F = {A→BC,B→C,A→B,AB→C}

  - 先合并，F = {A →BC，B→C，AB→C}  我们可以按照步骤老老实实的开始，不过很麻烦，下面我们直接观察
  - 先看B→C（因为这个不大可能被清除，就先看最简的），那么AB→C显然多余。F = {A →BC，B→C}
  - A →BC可以分成A →B和A →C，A →C显然是多余的，所以最后Fc =  {A →B，B→C} (其实按照语言逻辑上理解也是一样的，B→C，就说明C就是由B决定的，那A还有必要都决定BC么，A决定其B就好了，那就A →B吧)

#### 模式分解：

​		前面所说一个好的关系模式R若是“好的”形式，那么要做到不冗余，无插入、删除、更新异常。我们已经获知了判断一个关系模式的好与坏（根据F来判断R是否满足），那么当R是“不好”的形式时，我们就需要将它分解成模式集合{R1，R2,...,Rn}使得：

- 每个关系模式都是“好的”形式
- 分解总是无损连接分解
- 分解是保持依赖



**分解应有的特性：**

- 原模式R的所有属性都必须出现在分解后的（R1，R2）中；R = R1∪R2

- 无损连接的分解：对关系模式R上所有可能出现的关系r；r = П<sub>R1</sub>(R)⋈П<sub>R2</sub>(R)

  - R分解成R1和R2是无损连接，当且仅当下列依赖中的至少一个属于F+（分解后的两个子模式的**共同属性**必须是R1或R2的码）
    - R1∩R2 → R1
    - R1∩R2 → R2

- 保持依赖

  - 有效地检查更新操作（确保没有违反**任何**FD（非平凡的函数依赖）），允许分别验证子关系模式Ri，而不需要计算分解后的关系的连接

  - F在Ri上的限定是：Fi⊆F+，即F+所有只包含Ri中的属性的函数依赖Fi的集合

  - （F1∪F2∪...∪Fn)+  =  F+

  - 检查α→β在R到R1，R2，...,Rn的分解中是否保持，可进行下面的测试

    - ```
      result = α                 // 对于F中的每个α→β，投影到各个Ri中，判断是否有某个Ri能够保
      while(result有变化) do      //	持函数依赖α→β
      		for each 分解后的Ri
      		ti = (result∩Ri)+ ∩ Ri
      		result = result∪t
      ```

    - 若result包含β中的所有属性，α→β得到保持

    - 若对F中的每个α→β都能得到Ri满足函数依赖，那么该分解**保持依赖**

- 没有冗余

  - Ri最好满足BCNF或3NF（下一节说）

**例**，R = （A,B,C），F = {A→B，B→C}，假设有两种分解方式

- ​	第一种方式：R1 = （A，B）和R2 = （B，C）
  - 无损连接? R1∩R2 = {B}并且B→C，所以B是R2的码，R2 = （B)+ = {BC},所以是无损连接分解
  - 保持依赖？对于R1，有F1 = {A→B}；对于R2有F2 = {B→C}，所以(F1∪F2)+ = F+，所以保持依赖（正如本例，没必要全部计算F+，那样可能性也太多了，就找F里面函数包括的属性被Rn包含的就可以了，没有的话在另找，但没必要是全部！！！）
- ​    第二种方式：R1 = （A，B）和R2 = （A，C）
  - 无损连接？ R1∩R2 = {A}，A是R1和R2的超码，因此是无损连接分解
  - 保持依赖？对于R1，有F1 = {A→B}；对于R2，有F2= {A→C} ,(F1∪F2)+ 不等于F+的（B→C推不出来）因此是不保持依赖的



### 3、关系范式理论：

​		关系范式理论是一种设计数据库关系模型的标准

#### 1NF(第一范式)：

- 如果关系模式R中的所有属性的域都是原子的，则R称为属于**第一范式（1NF）**

- **原子：**如果某个域中元素被认为是不可分的，则这个域称为**原子的**

  - 非原子域的例子：复合属性（名字集合）,多值属性（电话号码）

    <img src="https://i.loli.net/2020/05/19/z6WFGkfaivxpuyj.png" alt="ZYQW9`0C2_A_2588XX_CNY5.png" width = 400 />

  - 非原子的值存储复杂并且容易导致属于冗余

- 如何处理非原子值

  - 对于组合属性：让每个子属性本身成为一个属性
  - 对于多值属性：为多值集合中的每个项创建一条元组

#### 2NF(第二范式)：

- 若在R在满足第一范式的基础下，R中的每一个**非主属性**<font color = red>完全依赖</font>于**候选键**，那么R属于**第二范式(2NF)**

- 注意，在2NF中，不是说仅仅候选键能够决定整个R的所有属性那么简单，而是说其它的**非主属性**（不包含在任何一个候选码中的属性称为非主属性）<font color = red>完全依赖</font>于候选键

  - 完全依赖：非主属性必须被候选码整体决定，候选码的子集不行！！！
  - 非主属性：R中抛去候选码的属性

- 如：R(S#,SN,SD,CN,G),其中，S#是学号，SN是姓名，SD是班级，CN是课程，G是成绩

  ​        函数依赖：F={S#→SN，S#→SD，S#CN→G}

  ​		候选键：{S#,CN},非主属性：SN和SD

  ​		判断该候选键能否完全决定SN、SD和G

  ​		可看出G是可以被完全决定，但是SN和SD不行，它们是被候选码的子集S#决定的

  ​		因此不符合第二范式

  ​		将其分解为R1(S#,SN,SD),R2(S#,CN,G),则R1和R2都符合第二范式

#### BCNF(Boyce-Codd范式)：

- 在R是1NF的前提下具有函数依赖集合F的关系模式R属于**BCNF**的条件是，当且仅当对F+中**！！所有！！**函数依赖α→β，下列至少有一项成立

  - α→β是平凡的函数依赖(即β⊆α)
  - α是R的超码（即R⊆α+，α→R）
  - （扩展）其实我们直接观察F就可以了，因为根据Armstrong公理中的任何一条，也没有说是能将左边α给缩小的，我们只需要看左边α要么包含候选码（也就是说本身就是个超码，怎么看？根据上面讲的α+算），要么就是个平凡依赖。

- 例，R = {A,B,C}

  ​        F = {A→B，B→C}

  ​		键 = {A}

  ​		R不属于BCNF，在B→C，B不是超码（B+ = {B,C}）

  ​		分解为R1 = {A，B}，R2 = {B, C}

  ​		R1与R2是BCNF(A是R1的超码，B是R2的超码)

  ​		无损连接分解?是（R1∩R2 = B，并且B是R2的超码）

  ​		保持依赖？是（F1 = {A→B}在R1上保持依赖，F2 = {B→C}在R2上保持依赖）

- **检查是否为BCNF的方法**

  - 平凡依赖一眼就看出来了，我们主要针对**非平凡依赖**α→β是否违反BCNF的要求

    - 计算α+，检验α+是否包含R的所有属性（只看F中的α就行了，不用看F+中所有的元素，原理在上面定义那边）

    - 当然，在检查R分解后还**仅仅用F**来判断是否满足BCNF就是错误的了

      - 例，考虑R(A,B,C,D),具有F = {A→B，B→C}

        分解为R1(A,B)和R2(A,C,D)

        因为F中的函数依赖都不是只包含（A,C,D）中的属性，因此我们可能会认为R2满足了BCNF（因为我们只看了F中的所有函数，误认为没有函数可以被R2包含，自然就认为R2满足BCNF)

        但其实，按照正常定理F+中的A→C是属于R2的一个函数，而这个函数表示R2不属于BCNF

        **因此（可以F下判别R是否违反BCNF，但必须在F+下判别R的分解式是否违反BCNF）**

  - **BCNF分解的算法**

    - ```
      result := {R};
      done := false
      compute F+;        //计算F+
      while(not done) do
      	if(result 中存在模式Ri不属于BCNF)  // 对于不是BCNF的Ri分解
      	then beign
      		令α→β是Ri上的一个非平凡函数依赖
      		使得α→Ri不属于F+，且α∩β = 空集
      		result := (result - Ri)∪(Ri - β)∪(α，β); //(α，β)必然是满足BCNF，并将
      		end										  //由于因α→β使得Ri不满足BCNF的
      	else done := true							  // 元素抛出来变为(Ri - β)
      ```

      这样做的Ri都属于BCNF，并且因为(Ri - β)∪(α，β)的缘故，这样α就是(α，β)的超码，这就会使得分解都是无损连接的。

    - 例，对class(course_id,title,dept_name,credits,sec_id,semester,year,building,room_number,capacity,time_slot_id)

      函数依赖：course_id → title,dept_name,credits

      ​					building,room_number → capacity

      ​					course_id,sec_id,semester,year → building,room_number,time_slot_id

      候选码：{course_id,sec_id,semetser,year};很简单就能看出来吧，不多解释

      R是否属于BCNF？很显然第一个和第二个依赖函数不包含候选码，两个都不是超码，所以不是

      分解：因为第一个函数使得R不是BCNF，那就从它开始，根据(result - Ri)∪(Ri - β)∪(α，β)

      ​			class被分解为

      ​			course(course_id,title,dept_name,credits) ；他肯定是BCNF了

      ​			class-1(course_id,sec_id,semester,year,building,room_number,capacity,time_slot_id)

      再判断class - 1是否满足BCNF：class-1的候选码是{course_id,sec_id,semetser,year}很显然														building,room_number → capacity中的左边并不是class - 1的超码

      再分解：class-1分解为classroom(building,room_number,capacity);这个肯定是BCNF了

      ​										section(course_id,sec_id,semester,year,time_slot_id)

      在判断section是否是BCNF：对course_id,sec_id,semester,year →time_slot_id可知													{course_id,sec_id,semester,year} 是section的候选码，仅剩的左边													course_id,sec_id,semester,year是超码，section是BCNF，分解结束

- **BCNF的缺点：**

  - BCNF分解不总是保持依赖的

  - 例，R = （J,K,L）

    F = {JK→L,L→K}

    两个候选码：JK和JL（这个很容易忽略）

    R不属于BCNF（L→K，K不是超码）

    R的分解都不满足保持依赖JK→L（都是二：二开的属性，肯定没有哪个Ri包含三个属性）

- 因此我们并不能总是满足这三个设计目标

  - 无损链接分解
  - BCNF
  - 保持依赖

#### 3NF(第三范式):

​		第三范式的出现是由于BCNF不能总是保持依赖，但是依赖对于有效检查更新是否违反FD是重要的，那么只能定义一种相对来说较若的范式，称为**第三范式(3NF)**。**1、**第三范式允许出现一些冗余。**2、**FD是可以在单个关系中检查，不必计算连接。**3、**第三范式总是存在到3NF的无损连接分解，并且总是保持依赖的。

- 关系模式R属于**第三范式（3NF）**当且仅当对所有F+中的函数依赖α→β下列条件至少有一个成立

  - α→β是平凡的函数依赖（和BCNF一样）
  - α是R的超码（和BCNF一样）
  - β - α中的每个属性A都包含于R中的一个候选码中(即A∈β - α是主属性，若α∩β = 空集，则A = β是主属性)

- 例，R = (J,K,L) F = {JK → L,L → K}

  两个候选码：JK和JL

  R属于3NF:对于JK→L，JK是R的超码；对于L→K，K包含在一候选码中，因此两个都满足3NF

  **有冗余？**有，下图的L和K存在大量冗余，J中还存在null值

  <img src="https://i.loli.net/2020/05/19/nG4aVIT3qswP71D.png" alt="B89GWTF_999_W_~4_@DYIX2.png" width = 200/>

**检查是否为3NF：**

- 优化：只需要检查F中的FD（非平凡依赖），不必检查F+中的所有FD
- 对每个依赖α→β，利用属性闭包来检查α是否是超码，如果是那就判断完成
- 如果不是超码，必须检查β-α中的每个属性是否包含在R的某个候选码中

**3NF分解算法：**

```
令Fc是F的正则覆盖；				//第一步就是尽可能的防止冗余
i := 0;
for each Fc中的函数依赖α→β do{
	if 没有模式Rj(1 <= j <= i)包含αβ   // 其实就是变相的说有没有Rj包含α作为超码，如果有的话直接就是			then begin				   // 这个α→β满足3NF了，如果没有那就直接造一个Ri = (α，β),让
		  	 i := i + 1				 // α→β必然满足，这就保证了保持依赖
             Ri = (α，β)
          end}
    if 没有模式Rj(1<=j<=i)包含R的候选码  //保证至少在一个Ri中存在R的候选码，从而保证无损连接分解
    	  then begin
    	  	i:=i+1;
    	  	Ri:=R的任意候选码；
    	  end
   	return (R1,R2,...,Ri)
```

例如，关系模式：cust_branker_branch = (customer_id,employee_id,branch_name,type)

​			函数依赖：1、customer_id,employee_id→branch_name,type

​								2、employee_id→branch_name

​								3、customer_id,branch_name→employee_id

​			计算正则覆盖：（像这样简单的一般不要用理论算，看就得了），2能够决定branch_name，1中包含2的										employee_id，一中的右边包含2的右边branch_name，所以1中的branch_name完全可											以剔除。

​										Fc = {customer_id,employee_id→type，employee_id→branch_name，												customer_id,branch_name→employee_id}

​			分解：R的候选码{customer_id,employee_id}

​						对customer_id,employee_id→type；刚上来别找Rj了，整体就一个R以外什么都没有吧，那就造一						个R1 = (customer_id,employee_id,type)

​						对employee_id→branch_name；我们看R1，不包含{employee_id，branch_name}吧，那么再造						一个R2 =（employee_id，branch_name）

​						对customer_id,branch_name→employee_id；我们看R1和R2还是不包含吧，那R3 = 						（customer_id,branch_name，employee_id）

​						没函数了，下面看是否包含原关系的候选码，好R1包含，循环就此结束

​						因为R2 =（employee_id，branch_name）是R3的一个子集合，删除即可

​						最后为R1 =  (customer_id,employee_id,type)和R3 =（customer_id,branch_name，							employee_id）

#### 例：

- 对于关系模式：R(A,B,C,D),F = {AB→C,C→D,D→A}

  - 列出R的所有候选码：

    老套路，先从单个的找，单个的显然不能推出C（AB→C摆在那儿的），先看AB, (AB)+ = (ABCD) = R,AB是。(BC)+ = (ABCD) = R,(BD)+ = (ABCD)。所以候选码是AB,BC,BC。因为C→D,D→A所以，R不是BCNF

  - 将R分解为BCNF：

    因为C→D所以R1（A,B,C）R2(C,D),R2满足BCNF，因为C→D,D→A所以C→A，所以R1（A,B,C）不是BCNF，R1再次分解为R11(A,C)和R12(B,C),R11和R12满足BCNF

  - 该分解是否保持依赖：((C→D)∪(C→A)∪(空集))+ 不等于F+，因此不保持依赖

- 对于关系模式：R(A,B,C,D,E,F),F = {A→B , A→C , BC→A , D→EF , F→E}

  - 列出R的所有候选码：

    AD和BCD

  - R属于BCNF还是3NF，或都不属于：

    F→E是非平凡依赖，并且F不是超码，并且E也不在超码中，因此两种都不是

  - 如果R不属于BCNF，将其分解为BCNF：

    R1 = (A,B,C) R2 =  (A,D,E,F) 由（A→B , A→C）

    R21 = （D,E,F） R22 = （A，D）由（D→EF）

    R211 = （E，F） R212 = （D,F）由（F→E）

    分解为(A, B, C)、(A，D)、(E，F)、(D, F)

  - 上述分解是否为保持依赖的：A→B , A→C , BC→A，F→E显然保持依赖，D→EF分解为D→E和D→F，因此D→E不保持依赖，因此该分解不保持依赖

#### 数据库设计目标：

- 关系数据库的设计目标是：
  - BCNF
  - 无损连接
  - 依赖保持
- 如果做不到上面的三点：
  - 缺少保持的依赖
  - 因3NF引起的冗余
- 除了超码之外，SQL并没有提供直接声明函数依赖的方法。可以通过断言验证FD，但代价过大
- 因此及时我们有一个保持以来的分解，使用SQL，我们也不能有效地检验左部是不是码的函数依赖
- 当我们小心地定义了E-R图，并正确地标识所有实体，则从E-R图生成的关系模式就不需要太多进一步的规范化
- 为提高性能可使用非规范化的模式（提高查找效率），也可以利用物化视图，既能提高效率又能避免错误

## **<a name="第六章">第六章：数据库管理系统实现技术</a>**

### 1、数据库存储记录的物理实现：

#### 基础回顾 -计算机系统的存储体系:

##### 存储体系（计算机组成原理基础）：

- 将不同性价比的存储器组织在一起，满足高速度、大容量、低价格需求

- CPU与内存直接交换信息，按存储单元（存储字）进行访问

- 外存按存储块（包含若干存储字），其信息需先装入内存，才能被CPU处理

- 下图是关于计算机是如何组成存储体系的

  <img src="https://i.loli.net/2020/05/20/zEcPdmB3MiaYGxq.png" alt="V21_7MN_YUTY___UCE~ZRPG.png" width = 200/>

##### 操作系统对数据的组织：

- 操作系统会将磁盘拆分为若干个磁盘块(也叫簇),而每个磁盘块都是由若干个连续扇区（磁盘的存储单位，其中包含很多字节）组成。

- 一个文件数据不一定能够连续的存储在磁盘块中，这时候如果想要完整的访问一个文件，就需要有顺序的访问存储该文件的磁盘块，操作系统提供了一种方法叫做文件分配表（FAT）

- 文件分配表：对应文件的每一个存储块都有一个表项相对应，该表相存储一个数值代表着下一个需要访问的数据块的位置。(然而文件的第一个磁盘块的存储并不在文件分配表中，一般都会在目录和文件夹中隐藏的表名存储的位置)

  <img src="https://i.loli.net/2020/05/20/GmgLBAnfNVUEwrJ.png" alt="_08SV~_OQ~_4D4YX__5ZOQQ.png" width = 400 />

- 操作系统不能够直接读取磁盘(因为读取数据的速度相差太大了)，但能够读取主存。那么就意味着磁盘中的数据要通过某种交换方式，交换到主存中。操作系统将主存划分为若干页面（页面的存储量一般与磁盘块的存储量相同，这样子方便交换）,当主存中没有想要的数据时，磁盘会将自己所含有的数据以磁盘块的单位写入到主存中去，方便CPU使用。

- 对于主存来说，一条记录的地址等于 页面：页内偏移量

- 当主存的页面被占满时，操作系统需要有一定的策略来替换主存中的页面（具体学习操作系统）

  <img src="https://i.loli.net/2020/05/20/HpfYPeuIzDRkUc9.png" alt="X_Q8__5P4@ZZJU_9_3__S3G.png" width = 500 /> 

#### 磁盘的结构与特性:

- 磁盘主要由盘面（磁道和扇区构成）、读写臂、磁头、主轴构成

  <img src="https://i.loli.net/2020/05/20/uPjt9CpgeAX2D3n.png" alt="U65X__1PU1BJF@RKHKG_V_2.png" width = 300/>

- 如上图所示，每个盘面由大大小小的同心圆（磁道）构成，每一个磁道上含有若干的扇区，当我们需要读取或写入数据时，首先需要寻找合适的盘面，再平移读写臂，找到合适的磁道后通过旋转盘面来找到合适的扇区。

- 因此数据的读写时间包括：寻道时间，旋转时间，传输时间。这其中寻道时间与传输时间占数据传输的大部分时间，因此降低寻道/旋转延迟时间对我们加快数据读取/写入速度是至关重要的。

- 降低寻道/旋转延迟：同一磁道连续块存储、同一柱面不同磁道并行块存储、多个磁盘并行块存储。

#### DBMS数据存储与查询实现的基本思想:

- 存储在磁盘上的记录的形式就是存储在磁盘块中一条条由01构成的比特串（块号 = 盘号：磁道：扇区范围），而DBMS需要做的正是将逻辑上表的数据存储在物理上的磁盘块中。

- 我们在创建数据库表的时候，同时也会定义索引，它们的作用就是记录我们存储的数据所在的磁盘块，方便我们对数据进行快速定位并操作。

- 操作系统中的文件分配表记录着磁盘块与文件的关系，数据库系统会让操作系统把自己定义的表作为文件后，再让操作系统先为该文件分配若干的磁盘块（这些磁盘块都是空的，让操作系统预先为数据库系统占位置）

- 当我们要读写数据的时候，需要在内存中进行读写，因此内存中的内存页与磁盘块就需要相应的映射。当数据不在内存中时，内存的缓冲区管理就会根据我们已经规定好的索引来在磁盘上找到相应的磁盘块进行交换数据。

  <img src="https://i.loli.net/2020/05/20/CJ2EhTzwc8LMNDI.png" alt="_B~IN___1_KTB_06KQC3DI9.png" width = 500 />

  <img src="https://i.loli.net/2020/05/20/1myJYobABUk85N4.png" alt="8PX7~A__GBH35LGQWSP@G_G.png" width = 300 />

  

#### 数据库之表和记录与磁盘的映射:

- **数据库记录在磁盘上的存储：**
  - 定长记录:指定了存储一个记录需要多少的比特位，其中一条记录中的各个属性元素的长度也是固定的。但这样可能会浪费很多存储空间（比如实际存储占用的空间不一定要这么大），也不宜扩展和修改。
  - 变长记录:变长记录在定长记录的基础上增加了分隔符来区分扩展和结束。但因为分隔符的原因也在一定程度上浪费了存储空间。
  - 非跨快存储：在每个磁盘块中存储的记录是有限的，但是当磁盘块不能够正好装入记录的整数倍时，就会有空间的浪费。非跨块存储，每一条记录完整的保存在一个磁盘块当中。
  - 跨块存储：为了解决空间浪费的问题，通过指针来指向同一记录在别的块的剩余部分。
- **数据库-表所占磁盘块的分配方法：**
  - 连续分配：数据被分配到连续的磁盘块上（会出现难以扩展的问题）
  - 链接分配：每一个被分配同一文件的磁盘块中包含指向下一个磁盘块的指针（简单扩展，但是访问速度会出现问题）
  - 按簇分配：按簇分配，簇是若干个连续的磁盘块，簇之间靠指针连接（综合上面两种方法的优点）
  - 索引分配：索引块中存放指向实际存储数据的磁盘块的指针

#### 数据库之文件组织方法：

​    数据组织需要考虑更新与检索的问题

-  更新将涉及数据存储空间的扩展与回收问题
- 检索将涉及扫描整个数据库的问题、大批量处理数据问题
- 不同的需求要求不同的数据组织方法和存取方法，因此针对不同需求我们需要考虑**文件组织**和**存取方法**



**文件组织(File Organization)：**

- 指的是数据组织成记录、块和访问结构的方式，包括把记录和块存储在磁盘上的方式，以及记录和块之间相互联系的方法

- **文件组织方法之一：无序记录文件（堆文件）：**

  - 特点：记录可存储与任意有空间的位置，磁盘上存储的记录是无序的。更新效率高，但检索效率可能低

  - 记录方法1：新纪录总是插入到文件尾部；删除记录时，可以直接删除该记录所在位置的内容，也可以在该记录前标记“删除标记”

    - 频繁增删记录会造成空间浪费，所以需要周期性重新组织数据库
    - **数据库重组：**通过移走被删除的记录使有效记录连续存放，从而回收那些由删除记录而产生的未利用空间

  - 记录方法2：在前者的基础上，新增记录可以利用那些标记为“删除”的记录空间

    <img src="https://i.loli.net/2020/05/20/UZxE3oWiTzyuPYb.png" alt="_Q3~LML__AKZJ~L11_T_3O8.png" width = 500 />

- **文件组织方法之二：有序记录文件（排序文件）：**

  - 特点：记录按某属性或属性组值得顺序插入，磁盘上存储得记录是有序得。检索效率可能高。

    用于存储排序的属性通常称为**排序字段**，通常排序字段使用关系中的主码，所以又称**排序码**。

    当按照排序字段进行检索时，速度得到很大的提高；但当按非排序字段检索时，速度不会比第一种提高很多。

    有序记录文件的更新效率会很低，因为在更新时需要移动其他记录，为插入记录留出空间

    <img src="https://i.loli.net/2020/05/20/v7FKlwUsI93HxeR.png" alt="TZ___ZAU0915___2_9T_GP0.png" width = 500 />

  - 改进：为将来可能会插入的元组预留空间，或使用一个临时的无序文件（也叫溢出文件）保存新增的记录。

    当采取溢出文件措施时，检索操作既要操作主文件，又要操作溢出文件，因此需要周期性的数据库重组

- **文件组织方法之三：散列文件：**

  - 特点：可以把记录按某属性或属性组的值，依据一个散列函数来计算其应存放的位置（这里说的桶号代表硬盘块号）。检索效率和更新效率都有一定程度的提高。

  - **散列字段和散列码：**用于进行散列函数计算的属性通常称为**散列字段**，散列字段通常也采用关系中的主码，所以又称**散列码**。

    <img src="https://i.loli.net/2020/05/20/I9vDymXWUrn6cPq.png" alt="A8XHB3RJFP~5J5__I_U@_GB.png" width = 500/>

  - 碰撞问题：当不同的记录被散列为同一桶号，这时该记录就按顺序存储在该桶（该磁盘块）中。检索时，也同样需要在桶内顺序检索某一记录

  - 扩展问题：当由于碰撞到一定程度时，桶中的空间已经被占满，这是就需要对桶进行扩展。最简单的办法是使用链接法（溢出桶开始，就使用链接分配了）处理溢出问题，将已经被塞满的桶中置入一个指向指向溢出桶中的溢出记录的指针（溢出桶是作为扩展用的磁盘空间）。

    <img src="https://i.loli.net/2020/05/20/SdvzQMnGER2VkjX.png" alt="_X`_3SIL60B6`VL_XGQK7RR.png" width = 400 />

- **文件组织方法之四：聚簇文件**

  - 聚簇：将具有相同或相似属性值的记录存放于连续的磁盘块中。

  - 多表聚簇：将若干个相互关联的Table存储于一个文件中，这样可以提高多表情况下的查询速度。

    <img src="https://i.loli.net/2020/05/20/rl7z4MGV2FJd6Of.png" alt="CQ@X____P_Z1NI_@K7`P_NF.png" width = 500 />

**存取方法(Access Method)：**

- 指的是对文件所采取的存储操作方法，一种文件组织可以采用多种存取方法进行访问。

### 2、数据库索引：

#### 索引：

- 索引是定义在存储表（table）基础之上，有助于无需检查所有记录而快速定位所需记录的一种**辅助存储结构**，由一系列存储在磁盘上的**索引项**组成，每一个索引项又由两部分构成：

  - 索引字段：由Table中的某些列中的值串接而成。索引中通常存储了索引字段的每一个值。索引字段类似于词典中的词条。
  - 行指针：指向Table中包含索引字段值的记录在磁盘上的存储位置。行指针类似于词条在书籍、词典中出现的页码。

- 存储索引项的文件为**索引文件**，相应的，存储表又称为**主文件**。

  <img src="https://i.loli.net/2020/05/20/qenRu2K4LJ91i8M.png" alt="Q5K24GGH~H78X`K_W_M6F_J.png" width = 500 />

- **索引文件：**索引文件是一种辅助存储结构，其存在与否都不会改变主存储表的物理存储结构；然而其存在，可以明显提高存储表的访问速度。索引文件组织方式有两种：

  - 排序索引文件：按索引字段值得某一种顺序组织存储（方便在索引文件中查找相应的“词条”）
  - 散列索引文件：依据索引字段值使用散列函数分配散列桶得方式存储

- 对于同一个表，可以针对不同的属性或属性组合建立不同的索引文件

- 索引文件比主文件小很多。通过检索一个小的**索引文件**，快速定位后，再针对得读取非**常大的主文件**。更新操作必须同步的更新索引文件和主文件。

#### SQL语言关于索引的基本知识：

- 当定义Table后，如果定义了主键，则系统将自动创建索引，利用索引对Table进行快速定位，检索与更新操作；
- 索引可由用户创建，也可由用户撤销；
- 当索引被创建后，无论是主索引，还是用户创建的索引，DBMS都会自动维护所有的索引，其与Table保持一致；
- 当Table被删除后，定义在该Table上的索引索引都会被自动撤销；
- 关于索引的创建和删除都已经在前面几章讲过了

#### 索引的分类：

- **稠密索引：**对于主文件中的每一个记录都会形成一个索引与它对应，指明该记录所在的位置。这样的索引称为稠密索引

  - 对于数据库中的**主键**，就是一种稠密索引

  - 对**非候选键属性**的稠密索引，索引文件中的索引字段值**是不重复**的，因此为了方便索引查找，主文件必须要按照被索引字段排序并且索引字段不是候选键。（让属性值相同的元组物理存储上相邻）

    若有重复的，那么针对主表中的每一个记录都会有索引相对应

    <img src="https://i.loli.net/2020/05/20/KWL9s6gApuwDTY5.png" alt="MB5EV9_~2_K__K_O_DYN__K.png" width = 400/>

- **稀疏索引：**对于主文件中部分记录形成相应的索引。这样的索引称为稀疏索引。对于稀疏索引，主文件必须是按对应索引字段属性排序存储

- **主索引：**通常是对每一存储块有一个索引项，索引项的总数和存储表所占的存储块数目相同，存储表的每一存储块的第一记录也成为锚记录；同时，组索引是按索引字段进行排序的一个有序文件（一种稀疏索引）

  <img src="https://i.loli.net/2020/05/20/s2a5cg7YxzWPRTl.png" alt="__CJ2UL3F1XHJ~_JG39NMV0.png" width = 500 />

  

- **辅助索引：**定义在主文件的任意或多个非排序字段上的辅助存储结构。（辅助索引是一种稠密索引）

  <img src="https://i.loli.net/2020/05/20/HMdBKQnNIwofkzU.png" alt="T5VNXMYDKNY_BVI3SC2_Q6Y.png" width = 500 />

  一个文件仅可以有一个主索引（通常建立在主码/排序码之上），但可以有多个辅助索引（辅助索引的原记录可以不按顺序）

- **聚簇索引：**是指索引中邻近的记录在主文件中也是临近存储的；聚簇索引通常是对聚簇字段上的每一个不同值都有一个索引项，一个主文件只能有一个聚簇文件。

  <img src="https://i.loli.net/2020/05/20/TOdnUqG3LIDMpNF.png" alt="RV@0ZLMB_RCGW61N_M4Q@2I.png" width = 500 />

  主索引与聚簇索引十分相似，但是主索引的总数不是由主文件上不同的聚簇值决定的，而是由主文件的存储块决定；

- **多级索引：**B/B+索引是多级索引中最常见的一种。当索引项比较多时，可以对索引再建立索引，依次类推，形成多级索引；而对于B/B+索引实际上是数据结构中的相关概论，具体感兴趣可以自己查。

  <img src="https://i.loli.net/2020/05/20/hGv1OHpMasLCZnu.png" alt="GW90LZ_T_XN_XFFON_IQQ2K.png" width = 400 />

- **散列索引：**使用散列技术组织的索引。

  <img src="https://i.loli.net/2020/05/20/alDjIEh7dsSPcF1.png" alt="_7_HHX4V5U80__KT0_B25`S.png" width = 500 />

### 3、数据库查询优化技术：

#### 什么是查询优化：

​		查询优化考虑的问题即为“如何能够使得数据库查询的执行时间最短”，其优化主要分为三个层次：语义优化、语法优化、执行优化。

- 语义优化：利用模型的语义及完整性规则，优化查询(这章不讨论)；

- 语法优化：利用语法结构，优化操作执行顺序（主要讨论）；

- 执行优化：存取路径和执行算法的选择与执行次序的优化；

  <img src="https://i.loli.net/2020/05/21/M1wbJc9osD6uVxp.png" alt="ZN0_8_3_J5~GKG5_Y9U_MIX.png" width = 400 />



**在我们深入讨论查询优化之前我们先看看为什么要进行查询优化：**

我们已知在数据库中，数据的记录数目动不动可达上万，甚至是百万的数目。而使用笛卡尔积进行两个这么庞大的数据库的连接会呈现更多的数目，这些数目必定会使得处理机难以执行这样的数据。

如：我们希望知道所有学生所选的课程名叫“DB”的科目的姓名 

​		П<sub>sname</sub>(σ<sub>SC.C# = Cousre.C#^Student.S#=SC.S#^S#=Cname = 'DB'</sub>(Student×SC×Course)）

​		假设这样的执行顺序是先笛卡尔积后选择再投影那么假设Student：10000条，Course：1000条，SC：10000*50条

那么笛卡尔积的数据总数应该为10000\*50\*10000\*1000条记录，这是一个特别庞大的数字，我们必须应该避免这样的执行顺序

​		我们可以改写成:П<sub>sname</sub>((σ<sub>Cname = 'DB'</sub>(Course)⋈SC)⋈Student),这样的顺序再执行，数据会不会就少了很多呢

因此对于关系代数的操作次序是非常重要的。



#### 语法优化（逻辑优化）：

正如为我们上面的例子，语法的优化正是对于SQL查询语句的执行逻辑进行优化。

**语法优化要考虑的几个问题：**	

- 其基本思想为：改变关系代数的操作次序，尽可能地早做选择和投影运算
- 要考虑关系代数的五种基本操作中哪两个能够交换次序
- 当次序交换后，两个表达式是否等价
- 关系代数表达式的等价变换定理及其证明
- 逻辑查询计划的形成

**逻辑优化的策略：**大体思路其实就是减少中间运算结果和争取做到最少扫描

- 尽可能早做选择和投影（使中间值尽可能变小，节省几个数量级的执行时间）
- 把选择与投影串接起来（一元运算序列可一起执行，只需对整个关系扫描一遍）
- 把投影与其前或后的二元运算结合起来（在第一次用关系时去掉一些无关的属性，可以避免多次扫描整个关系）
- 把某些选择与其前的笛卡尔积合并成一个连接（当R×S前有选择运算且其中有条件时R、S属性间比较运算时，可将其转化为连接运算可节省时间）
- 执行连接运算前对关系做适当预处理（文件排序、建立临时索引等，可是的俩关系公共值高效连接）
- 找到表达式里的公共子表达式(若公共子表达式结果不大，则预先计算，以后可读入结果)

**哪些关系代数操作能够交换次序：**

- **定理L1：**E1⋈E2 = E2⋈E1；E1×E2 = E2×E1
- **定理L2：**(E1⋈E2)⋈E3 = E1⋈(E2⋈E3);(E1×E2)×E3 = E1×(E2×E3)
- **定理L3：**П<sub>A1,...An</sub>(П<sub>B1,...,Bm</sub>(E)) = П<sub>A1,...An</sub>(E) ;其中A1,...An⊆B1,...Bn；（扫描两次变为一次）
- **定理L4：**σ<sub>F1</sub>(σ<sub>F2</sub>(E)) = σ<sub>F1^F2</sub>(E);（扫描两次变为一次）
- **定理L5：**П<sub>A1,...An</sub>(σ<sub>F</sub>(E)) = σ<sub>F</sub>(П<sub>A1,...,An</sub>(E)) ;其中F只涉及{A1,...An}的属性（先投影后选择，减少中间结果）
- **定理L6：**这条是做得到“尽可能地早做出选择的根本”
  - 若条件F只涉及E1中的属性；σ<sub>F</sub>(E1×E2) = σ<sub>F</sub>(E1)×E2
  - 若F = F1^F2，F1，F2分别只涉及E1，E2中的属性；σ<sub>F</sub>(E1×E2) = σ<sub>F1</sub>(E1)×σ<sub>F2</sub>(E2)
  - 若F = F1^F2，F1只涉及E1中的属性，而F2涉及E1,E2中的属性；σ<sub>F</sub>(E1×E2) = σ<sub>F2</sub>(σ<sub>F1</sub>(E1)×E2)
- **定理L7：**设E1，E2为俩关系代数表达式，A1,...,An是出现在E1或E2中的一些属性，其中B1,...,Bn出现在E1中，剩余属性C1,...Ck出现在E2中；П<sub>A1,...An</sub>(E1×E2) = П<sub>B1,...Bn</sub>(E1)×П<sub>C1,...Ck</sub>(E2)
- **定理L8:**   σ<sub>F</sub>(E1∪E2) = σ<sub>F</sub>(E1)∪σ<sub>F</sub>(E2)；E1和E2必须是相容的
- **定理L9:**   σ<sub>F</sub>(E1-E2) = σ<sub>F</sub>(E1)-σ<sub>F</sub>(E2)；（减少中间运算结果）
- **定理L10:**   П<sub>A1,...An</sub>(E1∪E2) = П<sub>A1,...An</sub>(E1)∪П<sub>A1,...An</sub>(E2)；其中A1,...An是E = E1∪E1中的一些属性

**下面我来举个例子：**假设我们定义了一图书馆的关系数据库

BOOKS(TITLE,AUTHOR,PNAME,LC_NO)
PUBLISHERS(PNAME,PADDR,PCITY)
BORROWERS(NAME,ADDR,CITY,CARD_NO)
LOANS(CARD_NO,LC_NO,DATE)
同时我们定义了下面的视图XLOANS
XLOANS = П<sub>TITLE,AUTHOR,PNAME,LC_NO,NAME,ADDR,CITY,CARD_NO,DATE</sub>(σ<sub>BORROWERS.CARD_NO=LOANS.CARD_NO^BOOKS.LC_NO=LOANS.LC_NO</sub>(LOANS×BORROWERS×BOOKS))

当查询“查出1978年1月1日前被借出的所有书名” SELECT TITLE FROM XLOANS WHERE DATE <= 1/1/78

其会转换为П<sub>TITLE</sub>(σ<sub>DATE<='1/1/78'</sub>(XLOANS))的关系代数表达式

其执行的语法树为（从下向上执行）：

<img src="https://i.loli.net/2020/05/21/Zp4otWxkB1iYwq7.png" alt="U_AM7G_2MCJF2LRZ@D~0KJ1.png" width = 500 />

<img src="https://i.loli.net/2020/05/21/iFA6L38XeCWtPGV.png" alt="__IHYHKK29MM__WGYQUS_AM.png" width = 500 />

<img src="https://i.loli.net/2020/05/21/qJjRnXhIKegdErz.png" alt="_Y_FG3K__E5_UKV_RT6_G7K.png" width = 500/>

<img src="https://i.loli.net/2020/05/21/rbC1EXWM7mhyPz3.png" alt="XSU6X__C6L~___M_BRMF0HW.png" width = 500 />



